<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java Technical Documentation</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="icon" href="./Assets/java.png" />
</head>

<body>
    <button class="menu-toggle" onclick="toggleMenu()">☰</button>

    <div class="container">
        <nav id="navbar">
            <header>
                <h1>Java Documentation</h1>
            </header>
            <ul>
                <li><a class="nav-link" href="#java_introduction">Java Introduction</a></li>
                <li><a class="nav-link" href="#java_history">Java History</a></li>
                <li><a class="nav-link" href="#module1_core_java">Module I: Core Java</a></li>
                <li><a class="nav-link" href="#module2_oops">Module II: OOPs</a></li>
                <li><a class="nav-link" href="#module3_collections">Module III: Collections</a></li>
                <li><a class="nav-link" href="#module4_gui">Module IV: GUI</a></li>
                <li><a class="nav-link" href="#module5_database">Module V: Database</a></li>
                <li><a class="nav-link" href="#module6_spring_boot">Module VI: Spring Boot</a></li>
                <li><a class="nav-link" href="#module7_aop">Module VII: AOP</a></li>
                <li><a class="nav-link" href="#module8_thymeleaf">Module VIII: Thymeleaf</a></li>
                <li><a class="nav-link" href="#module9_postman">Module IX: Postman</a></li>
                <li><a class="nav-link" href="#module10_crud">Module X: CRUD</a></li>
                <li><a class="nav-link" href="#naming_conventions">Java Naming Conventions</a></li>
                <li><a class="nav-link" href="#java8_features">Java 8 Features</a></li>
                <li><a class="nav-link" href="#java17_features">Java 17 Features</a></li>
                <li><a class="nav-link" href="#java21_features">Java 21 Features</a></li>
                <li><a class="nav-link" href="#dsa_concepts">DSA Concepts</a></li>
                <li><a class="nav-link" href="#references">References</a></li>
            </ul>
        </nav>

        <main id="main-doc">
            <section class="main-section" id="java_introduction">
                <header>
                    <h2>Java Introduction</h2>
                </header>
                <div class="java-logo">☕︎</div>
                <p>Java is a high-level, class-based, object-oriented programming language that is designed to have as
                    few implementation dependencies as possible. It is a general-purpose programming language intended
                    to let programmers <strong>write once, run anywhere (WORA)</strong>, meaning that compiled Java code
                    can run on all
                    platforms that support Java without the need to recompile.</p>

                <div class="feature-box">
                    <h3>Key Features of Java:</h3>
                    <ul>
                        <li><strong>Platform Independent:</strong> Java programs can run on any platform that has a Java
                            Virtual Machine (JVM).</li>
                        <li><strong>Object-Oriented:</strong> Everything in Java is an object, promoting code
                            reusability and modularity.</li>
                        <li><strong>Secure:</strong> Java provides a secure environment with built-in security features.
                        </li>
                        <li><strong>Robust:</strong> Strong memory management and exception handling.</li>
                        <li><strong>Multithreaded:</strong> Supports concurrent execution of multiple threads.</li>
                        <li><strong>Simple:</strong> Easy to learn and understand syntax.</li>
                        <li><strong>High Performance:</strong> Java uses a Just-In-Time (JIT) compiler that converts
                            bytecode into native machine code at runtime, significantly improving performance compared
                            to purely interpreted languages.</li>
                        <li><strong>Distributed:</strong> Java's networking capabilities are well-developed, making it
                            easy to create distributed applications. Technologies like RMI (Remote Method Invocation)
                            enable objects to interact across a network.</li>
                        <li><strong>Dynamic:</strong> Java is designed to adapt to an evolving environment. It can load
                            classes dynamically, which is crucial for features like reflection and allowing for runtime
                            modifications.</li>
                    </ul>
                </div>

                <h3>Basic Java Syntax and Structure</h3>
                <p>Let's look at a simple "Hello, World!" example to understand the basic syntax of a Java program.</p>
                <pre><code>
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
                </code></pre>
                <p><strong>Explanation of the components:</strong></p>
                <ul>
                    <li><strong><mark>public class HelloWorld</mark></strong> :
                        <ul>
                            <li><strong>public</strong> : This is an access modifier, meaning this class is accessible
                                from
                                any other class.</li>
                            <li><strong>class</strong> : This keyword is used to declare a class. In Java, all code
                                resides
                                within classes.</li>
                            <li><strong>HelloWorld</strong> : This is the name of our class. By convention, class names
                                start
                                with an <b>uppercase letter</b>. The file name must match the class name (e.g.,
                                <mark>HelloWorld.java</mark>).
                            </li>
                        </ul>
                    </li>
                    <li><strong><mark>public static void main(String[] args)</mark></strong> : This is the main method,
                        the entry point
                        for any Java application.
                        <ul>
                            <li><strong>public</strong> : Again, an access modifier, making the method accessible from
                                anywhere.</li>
                            <li><strong>static</strong> : This keyword means the method belongs to the class itself, not
                                to
                                a
                                specific object instance. It can be called without creating an object of the class.</li>
                            <li><strong>void</strong> : This indicates that the method does not return any value.</li>
                            <li><strong>main</strong> : This is the name of the method. The Java Virtual Machine (JVM)
                                looks
                                for a method with this specific signature to start execution.</li>
                            <li><strong>String[] args</strong> : This declares a parameter named
                                <i><strong>args</strong></i>, which is
                                an array of <i><strong>String</strong></i> objects. It's used to receive command-line
                                arguments
                                when the program is run.
                            </li>
                        </ul>
                    </li>
                    <li><strong><mark>System.out.println("Hello, World!");</mark></strong> : <i><b>This line prints the
                                string
                                "Hello, World!"
                                to the console.</b></i>
                        <ul>
                            <li><strong>System</strong> : A built-in Java class that provides access to the system,
                                including
                                input/output streams.</li>
                            <li><strong>out</strong> : A static member of the <i><strong>System</strong></i> class,
                                which is an
                                instance
                                of <i><strong>PrintStream</strong></i> . It represents the standard output stream.</li>
                            <li><strong>println()</strong> : A method of the <i><strong>PrintStream</strong></i> class
                                that prints a
                                string to the console and then moves the cursor to the next line.</li>
                        </ul>
                    </li>
                </ul>
                <div class="highlight">
                    <p><strong>Note: </strong>Every statement in Java must end with a semicolon (<strong>;</strong>).
                    </p>
                </div>

                <h3>How to Compile and Run a Java Program:</h3>
                <p>To execute the "Hello, World!" program, you'll need the Java Development Kit (JDK) installed on your
                    system.</p>
                <ol>
                    <li><strong>Save the code:</strong> Save the code above in a file named
                        <mark>HelloWorld.java</mark> . Make sure the file name exactly matches the class name.
                    </li>
                    <li><strong>Open a terminal or command prompt:</strong> Navigate to the directory where you saved
                        your <mark>HelloWorld.java</mark> file.</li>
                    <li><strong>Compile the Java source code:</strong> Use the Java compiler ( <mark>javac</mark> ) to
                        compile the <mark>.java</mark> file into bytecode (a <mark>.class</mark> file).
                        <pre><code>
javac HelloWorld.java
                            </code></pre>
                        <p>If the compilation is successful, a file named <mark>HelloWorld.class</mark> will be created
                            in the same directory. This <mark>.class</mark> file contains the Java bytecode.</p>
                    </li>
                    <li><strong>Run the Java program:</strong> Use the Java application launcher ( <mark>java</mark> )
                        to
                        execute the compiled bytecode.
                        <pre><code>
java HelloWorld
                            </code></pre>
                        <p><strong>Note:</strong> You do not include the <mark>.class</mark> extension when running the
                            program.</p>
                    </li>
                    <li><strong>Observe the output:</strong> The program will print the following to your console:
                        <pre><code>
Hello, World!
                            </code></pre>
                    </li>
                </ol>

                <h3>Java Architecture (JVM, JRE, JDK)</h3>
                <p>Java follows a unique architecture that includes several key components, each playing a crucial role
                    in how Java programs are developed and executed.</p>
                <ul>
                    <li><strong>Java Source Code (.java)</strong> - Human readable code written by programmers. This
                        code is then compiled into bytecode.</li>
                    <li><strong>Java Compiler (javac)</strong> - A tool that is part of the JDK. It takes the Java
                        source code (.java files) and translates it into platform-independent bytecode (.class files).
                    </li>
                    <li><strong>Bytecode (.class)</strong> - This is an intermediate, machine-independent code. It's not
                        directly executable by the operating system but can be run on any platform that has a Java
                        Virtual Machine.</li>
                    <li><strong>Java Virtual Machine (JVM)</strong> - The heart of Java's "write once, run anywhere"
                        capability. The JVM is an abstract machine that provides a runtime environment in which Java
                        bytecode can be executed. It interprets and executes the bytecode on the specific underlying
                        hardware and operating system. The JVM performs tasks like:
                        <ul>
                            <li>Loading, verifying, and executing bytecode.</li>
                            <li>Providing a runtime environment.</li>
                            <li>Managing memory (garbage collection).</li>
                        </ul>
                    </li>
                </ul>

                <h4>Detailed Explanation of JVM, JRE, and JDK:</h4>
                <p>To fully understand the Java ecosystem, it's essential to differentiate between the JVM, JRE, and
                    JDK:</p>

                <div class="component-box">
                    <h3>1. Java Virtual Machine (JVM)</h3>
                    <p>The JVM is a specification that defines how Java bytecode is executed. It is a runtime
                        environment that acts as an interpreter and executor for Java bytecode. When you run a Java
                        program, the JVM reads the bytecode and translates it into native machine code instructions that
                        the underlying operating system can understand. Different operating systems and hardware
                        architectures have their own specific implementations of the JVM, which is what enables Java's
                        platform independence.</p>
                    <p>Key responsibilities of the JVM include:</p>
                    <ul>
                        <li><strong>Class Loader:</strong> Dynamically loads classes into the JVM's memory.</li>
                        <li><strong>Bytecode Verifier:</strong> Checks the bytecode for security and integrity before
                            execution.</li>
                        <li><strong>Execution Engine:</strong> Executes the bytecode. This engine can include an
                            interpreter (which executes bytecode instruction by instruction) and a Just-In-Time (JIT)
                            compiler (which compiles frequently executed bytecode into native machine code for faster
                            execution).</li>
                        <li><strong>Garbage Collector:</strong> Automatically manages memory by reclaiming memory
                            occupied by objects that are no longer in use, preventing memory leaks.</li>
                        <li><strong>Runtime Data Areas:</strong> These are the memory areas used by the JVM during
                            program execution, including the Heap, Method Area, Stack, PC Registers, and Native Method
                            Stacks.</li>
                    </ul>
                </div>

                <div class="component-box">
                    <h3>2. Java Runtime Environment (JRE)</h3>
                    <p>The JRE is a software package that provides the minimum requirements for executing a Java
                        application. It includes the JVM, along with the core Java class libraries and supporting files.
                        If you only want to run Java applications and not develop them, you only need the JRE.</p>
                    <p>The JRE typically consists of:</p>
                    <ul>
                        <li><strong>JVM:</strong> The Java Virtual Machine, as described above.</li>
                        <li><strong>Java Class Libraries (API):</strong> A set of standard classes and packages that
                            provide fundamental functionalities like input/output, networking, utilities, and data
                            structures. These libraries are essential for any Java application to function.</li>
                        <li><strong>Supporting Files:</strong> Other configuration files and resources required by the
                            JVM and the class libraries.</li>
                    </ul>
                    <p>In essence, JRE = JVM + Java Class Libraries.</p>
                </div>

                <div class="component-box">
                    <h3>3. Java Development Kit (JDK)</h3>
                    <p>The JDK is a comprehensive software development kit that provides all the tools and resources
                        necessary to develop, compile, debug, and run Java applications. It includes the JRE, along with
                        development tools such as the Java compiler (javac), debugger (jdb), archiver (jar), and
                        documentation generator (javadoc).</p>
                    <p>If you are a Java developer, you need the JDK. It provides the complete environment to write,
                        compile, and execute Java programs.</p>
                    <p>The JDK typically includes:</p>
                    <ul>
                        <li><strong>JRE:</strong> The Java Runtime Environment, enabling the execution of Java
                            applications.</li>
                        <li><strong>Development Tools:</strong>
                            <ul>
                                <li><code>javac</code> The Java compiler.</li>
                                <li><code>java</code> The Java application launcher (which also invokes the JVM).</li>
                                <li><code>jdb</code> The Java debugger.</li>
                                <li><code>jar</code> The Java archive tool (for packaging Java classes and associated
                                    metadata).</li>
                                <li><code>javadoc</code> The documentation generator.</li>
                                <li>And many other utilities for profiling, monitoring, etc.</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>In essence, JDK = JRE + Development Tools.</strong></p>
                </div>

                <p>In summary, if you just want to run a Java program, you need the JRE. If you want to develop Java
                    programs, you need the JDK, which inherently includes the JRE and JVM.</p>

                <div class="highlight">
                    <p><strong>Note: </strong>
                        Java is considered platform-independent because its source code compiles into bytecode, which is
                        a
                        universal, platform-neutral intermediate format. This bytecode can then be executed on any
                        device
                        that has a compatible Java Virtual Machine (JVM). However, the JVM itself is platform-dependent;
                        a
                        different version of the JVM is specifically designed and implemented for each underlying
                        operating
                        system (e.g., Windows, macOS, Linux). So, while your Java code is 'write once, run anywhere,'
                        the
                        'run anywhere' relies on the presence of a platform-specific JVM.
                    </p>
                </div>


            </section>

            <section class="main-section" id="java_history">
                <header>
                    <h2>Java History</h2>
                </header>

                <p>Java was originally developed by <b>James Gosling</b> at <b>Sun Microsystems</b> and released in
                    <b>1995</b>. The
                    development of Java started in <b>1991</b> as part of the <b>Green Project, aiming to create a
                        programming
                        language for intelligent consumer electronic devices</b>.
                </p>

                <div class="feature-box">
                    <h3>Java Timeline:</h3>
                    <ul>
                        <li><strong>1991:</strong> The <b>Green Project</b> started at Sun Microsystems, led by James
                            Gosling.
                            The language was initially named <b>"Oak."</b></li>
                        <hr>
                        <li><strong>1995:</strong> <b>Java 1.0</b> released to the public. It introduced the "Write
                            Once, Run
                            Anywhere" (<b>WORA</b>) principle, quickly gaining popularity for web applets. This was the
                            OG. "Write once, debug everywhere." <b>Applets, AWT, and chaos</b>.</li>
                        <hr>
                        <li><strong>1997:</strong> </strong> <b>Java 1.1</b> released, bringing significant features
                            like
                            <b>Inner Classes,
                                JavaBeans, JDBC (Java Database Connectivity), RMI and Reflection</b>. Java started
                            pretending to be <b>enterprise-ready</b>.
                        </li>
                        <hr>
                        <li><strong>1998:</strong> <b>Java 1.2</b>, dramatically <b>rebranded</b> as Java 2 Platform,
                            Standard Edition (J2SE), was released, introducing the <b>Collections Framework</b>,
                            <b>Swing</b> for rich <b>GUI</b> applications, and the <b>Java HotSpot VM</b>, with the
                            <b>JIT compiler</b> making its debut.
                        </li>
                        <hr>
                        <li><strong>2000:</strong> <b>Java 1.3 (J2SE 1.3)</b> was released, with the <b>HotSpot JVM</b>
                            becoming the default, bringing significant performance improvements and RMI enhancements.
                        </li>
                        <hr>
                        <li><strong>2002:</strong> <b>Java 1.4 (J2SE 1.4)</b> was released, adding useful features like
                            <b>Assertions</b>, the <b>New I/O API (NIO)</b>, <b>XML processing</b>, and <b>regular
                                expressions (Regex)</b>, marking it as a "boring but useful" update that also introduced
                            built-in <b>logging</b>.
                        </li>
                        <hr>
                        <li><strong>2004:</strong> <b>Java 5.0 (rebranded from 1.5 to emphasize its significance)</b>
                            was a landmark release that introduced <b>Generics, Annotations, Autoboxing/Unboxing, Enums,
                                enhanced for-loops, and Varargs</b>, significantly improving developer productivity and
                            truly marking a point where "Java grew up".</li>
                        <hr>
                        <li><strong>2006:</strong> <b>Java 6 (Java SE 6)</b> was released, primarily bringing further
                            performance improvements, <b>support for scripting languages</b> (like JavaScript and Ruby
                            via JSR 223), and an <b>improved API</b> for web services, though it largely felt like it
                            was "just waiting for JDK 7".</li>
                        <hr>
                        <li><strong>2009: Oracle Acquires Sun Microsystems:</strong> In April
                            2009, Oracle Corporation
                            announced its intention to acquire Sun Microsystems, a deal that
                            was finalized in January
                            2010. This acquisition included all of Sun's software and
                            hardware assets, most notably
                            Java. This marked a significant shift in the ownership and
                            stewardship of the Java platform,
                            bringing it under Oracle's wing.</li>
                        <hr>
                        <li><strong>2011:</strong> <b>Java 7 (Java SE 7)</b> was the <b>first major release after the
                                Oracle acquisition</b>, introducing <b>Project Coin</b> (a set of small language
                            enhancements like the Diamond operator, <b>try-with-resources</b>, and simplified varargs
                            warnings), improvements to the Fork/Join framework, and <b>strings in switch</b> statements,
                            though still notably <b>lacking lambdas</b>.</li>
                        <hr>
                        <li><strong>2014:</strong> <b>Java 8 (Java SE 8)</b> was a <b>landmark release</b> that
                            fundamentally changed how Java is programmed by introducing Lambda expressions, the Stream
                            API (for functional-style operations on collections), the new Date and Time API, and default
                            methods in interfaces, signifying that Java had truly learned <b>functional programming with
                                LAMBDAS, Streams, and Optionals</b>.</li>
                        <hr>
                        <li><strong>2017:</strong> <b>Java 9 (Java SE 9)</b> was released, with its most significant
                            feature being the <b>Java Platform Module System (JPMS)</b>, also known as Project Jigsaw,
                            which aimed to improve modularity and scalability. This version also introduced JShell (an
                            interactive Java shell) and private interface methods, effectively ushering in an era where
                            <b>"your classpath is now deprecated"</b>.
                        </li>
                        <hr>
                        <li><strong>2018-Present:</strong> Following Java 9, Oracle shifted to a
                            rapid release cadence,
                            releasing new versions every six months.
                            <hr>
                            <ul>
                                <li><strong>Java 10 (2018):</strong> Introduced the <b>`var` keyword</b>. The <b>"we
                                        release every
                                        6 months now"</b> era began.</li>
                                <hr>
                                <li><strong>Java 11 (2018):</strong> The <b>second LTS</b> (Long-Term Support version)
                                    release, standardized the <b>HTTP Client API (HTTP/2)</b>, introduced <b>ZGC</b> (a
                                    scalable low-latency garbage collector), and allowed <mark>var</mark> in
                                    <b>lambda</b> parameters, effectively serving as the <b>"please stop using Java
                                        8"</b>
                                    update.
                                </li>
                                <hr>
                                <li><strong>Java 12-16 (2019-2021):</strong> Non-LTS releases that brought features like
                                    <b>Switch expressions, text blocks, and records</b>.
                                </li>
                                <hr>
                                <li><strong>Java 17 (2021):</strong> The <b>third LTS release</b>, focused on features
                                    like <b>sealed classes, pattern matching</b> for switch expressions, and an
                                    improved <b>Foreign Function</b> and <b>Memory API</b>, earning it the reputation as
                                    the <b>"we're stable again"</b> release.</li>
                                <hr>
                                <li><strong>Java 21 (2023):</strong> Java 21, the <b>latest LTS release (released in
                                        September 2023)</b>, introduced <b>"game-changer"</b> features such as
                                    <b>Virtual
                                        Threads, Record Patterns, Pattern Matching for Switch,</b> and <b>Sequenced
                                        Collections,</b> significantly advancing the platform for <b>structured
                                        concurrency and
                                        modern data handling.</b>
                                </li>
                                <hr>
                                <li><strong>Java 22 (2024):</strong> Released in <b>March 2024</b>. A non-LTS release
                                    that
                                    continued to build on <b>preview features</b>, including the second preview of
                                    <b>Structured
                                        Concurrency and Scoped Values,</b> along with <b>Unnamed Variables &
                                        Patterns,</b> and the
                                    <b>Foreign Function & Memory API</b>.
                                </li>
                                <hr>
                                <li><strong>Java 23 (2024):</strong> Released in <b>September 2024</b>. A non-LTS
                                    release that
                                    introduced <b>Primitive Types in Patterns, `instanceof`, and `switch` (Preview),</b>
                                    further <b>previews of the Class-File API, Stream Gatherers, Structured
                                        Concurrency,</b>
                                    and <b>Scoped Values,</b> and also brought <b>Markdown Documentation Comments</b>.
                                </li>
                                <hr>
                                <li><strong>Java 24 (2025):</strong> Released in <b>March 2025</b>. This non-LTS release
                                    featured significant advancements such as the <b>finalization of Stream
                                        Gatherers</b> and
                                    the <b>Class-File API</b>, further previews for <b>Structured Concurrency</b> and
                                    <b>Scoped Values</b>,
                                    and experimental features like <b>Generational Shenandoah</b>. It also focused on
                                    <b>quantum-resistant cryptographic algorithms</b>.
                                </li>
                                <hr>
                                <li><strong>Java 25 (Expected September 2025):</strong> The next anticipated LTS
                                    release.</li>
                                <hr>
                            </ul>
                        </li>
                    </ul>

                    <h3>Release Type Summary:</h3>
                    <ul>
                        <li><b>Non-LTS releases (Java 10, 12, 13, 14, 15, 16, 18, 19, 20, 22, 23, 24, etc.)</b> continue
                            to introduce incremental features and improvements.</li>
                        <hr>
                        <li><b>LTS releases (Java 8, 11, 17, 21, and the upcoming 25)</b> provide long-term
                            support and stability, making them the recommended versions for most production
                            environments.</li>
                        <hr>
                    </ul>
                </div>

                <div class="highlight">
                    <p><strong>🎉 Java's Milestone! 🎉 </strong> Java recently celebrated its <b>30th birthday</b> on
                        <b>May 23, 2025</b>! 🥳 Since its public debut in 1995, Java has evolved into one of the most
                        enduring and widely used programming languages, powering everything from enterprise applications
                        🏢 to mobile devices 📱 and big data platforms 📊, demonstrating its remarkable adaptability and
                        continued relevance in the tech world. 💻🚀
                    </p>
                </div>

                <div class="java_recommendations">
                    <h3>Recommendations for Java Development:</h3>
                    <ul class="recommendations">
                        <li><span class="custom-checkmark">✅</span> Use LTS versions (8, 11, 17, 21, 25) unless you love
                            pain.</li>
                        <li><span class="custom-checkmark">✅</span> Java 8+ = Learn Streams/Lambdas. No excuses.</li>
                        <li><span class="custom-checkmark">✅</span> Java 21+ = Virtual threads = free scalability.</li>
                    </ul>
                </div>

                <div class="highlight">
                    <p><strong>Fact File:</strong> Java was initially called "Oak" but was renamed to "Java" in 1995.
                        The
                        name <b>"Oak"</b> came from an <b>oak tree</b> 🌳 that stood outside the office of James
                        Gosling, the creator of
                        Java. However, "Oak" was already a <b>registered trademark</b>. During a brainstorming session
                        fueled
                        by coffee, the team chose the name <b>"Java" - inspired by the Indonesian island known for its
                            coffee</b>. This connection led to Java's iconic coffee cup logo ☕, symbolizing energy and
                        universality!</p>
                </div>

            </section>

            <section class="main-section" id="module1_core_java">
                <header>
                    <h2>Module I: Core Java</h2>
                </header>

                <h3>1. Variables, Data Types & Operators</h3>
                <h4>Variables:</h4>
                <p><strong>Variables</strong> are named memory locations that act as containers for storing data values.
                    In Java, a <b>strongly typed language</b>, every variable must be explicitly declared with a
                    specific
                    data type before it can be used. This declaration informs the compiler about the type of data the
                    variable will hold and the amount of memory it needs to allocate. This strong typing helps prevent
                    errors and ensures type safety during compilation and runtime.</p>

                <h4>Variable Naming Conventions:</h4>
                <p>In Java, following standard naming conventions is crucial for code readability and
                    maintainability. These conventions promote code clarity, reduce errors, and facilitate collaboration
                    among developers.</p>
                <ul>
                    <li><strong>camelCase:</strong> Use lower camel case for variable names <b>(e.g.,
                            `firstName`, `timeToFirstLoad`)</b>. The first letter of a variable name should be
                        lowercase, and
                        subsequent words start with an uppercase letter, without spaces or underscores.</li>
                    <li><strong>Meaningful Names:</strong> Choose descriptive names reflecting the
                        variable's purpose <b>(e.g., `customerName` instead of `cn`)</b>.</li>
                    <li><strong>Constants:</strong> Use all uppercase with underscores separating
                        words for constants declared as `final` <b>(e.g., `MAX_VALUE`, `API_KEY`)</b>.</li>
                    <li><strong>Avoid Single Characters:</strong> Refrain from using
                        single-character variable names except for loop counters <b>(e.g., `i`, `j`, `k`)</b>.</li>
                    <li><strong>No Spaces:</strong> Variable names cannot contain spaces; use camel
                        case instead.</li>
                    <li><strong>Start with Letter:</strong> Begin variable names with a letter, not
                        a digit.</li>
                    <li><strong>Avoid `_` or `$`:</strong> Variable names should not start with an
                        underscore `_` or dollar sign `$` characters, <b>even though both are technically allowed.</b>
                    </li>
                    <li><strong>Case Sensitivity:</strong> Java is case-sensitive; <b>`myVar`</b> and
                        <b>`myvar`</b> are distinct variables.
                    </li>
                    <li><strong>Avoid Keywords:</strong> You cannot use Java keywords <b>(like `int`,
                            `class`, `public`)</b> or reserved words as variable names.</li>
                    <li><strong>Boolean variables:</strong> Should be prefixed with "is" <b>(e.g.,
                            `isFinished`)</b>.</li>
                    <li><strong>Private class variables:</strong> Should have an underscore prefix
                        <b>(e.g., `_downloadTimer`)</b>.
                    </li>
                    <li><strong>Be mindful of length:</strong> While descriptive names are important, avoid excessively
                        long names.</li>
                </ul>

                <p><strong>Examples:</strong></p>
                <ul>
                    <li>firstName</li>
                    <li>totalAmount</li>
                    <li>isValidUser</li>
                    <li>employeeId</li>
                </ul>

                <h4>Data Types:</h4>
                <p>Java's data types are categorized into two main groups:</p>
                <ul>
                    <li>
                        <strong>Primitive Types:</strong> These are the fundamental building blocks for data
                        manipulation. They hold simple, single values directly in memory. Java has 8 primitive data
                        types, each with a predefined size and range.
                        <ul>
                            <li><strong><mark>byte</mark>:</strong> Stores whole numbers from -128 to 127. <strong>Size:
                                    1 byte (8 bits)</strong>. Default value: 0.</li>
                            <li><strong><mark>short</mark>:</strong> Stores whole numbers from -32,768 to 32,767.
                                <strong>Size: 2 bytes (16 bits)</strong>. Default value: 0.
                            </li>
                            <li><strong><mark>int</mark>:</strong> Stores whole numbers from -2,147,483,648 to
                                2,147,483,647. This is the **default integer type**. <strong>Size: 4 bytes (32
                                    bits)</strong>. Default value: 0.</li>
                            <li><strong><mark>long</mark>:</strong> Stores very large whole numbers. Used when `int` is
                                not large enough. Requires an 'L' or 'l' suffix (e.g., `100L`). <strong>Size: 8 bytes
                                    (64 bits)</strong>. Default value: 0L.</li>
                            <li><strong><mark>float</mark>:</strong> Stores single-precision floating-point numbers
                                (decimals). Used when memory is a concern. Requires an 'F' or 'f' suffix (e.g.,
                                `3.14f`). <strong>Size: 4 bytes (32 bits)</strong>. Default value: 0.0f.</li>
                            <li><strong><mark>double</mark>:</strong> Stores double-precision floating-point numbers.
                                This is the **default floating-point type** and is generally preferred for decimal
                                values due to higher precision. <strong>Size: 8 bytes (64 bits)</strong>. Default value:
                                0.0d.</li>
                            <li><strong><mark>boolean</mark>:</strong> Stores `true` or `false` values only. Represents
                                logical states. <strong>Size: 1 bit (though typically JVM allocates 1 byte for
                                    storage)</strong>. Default value: `false`.</li>
                            <li><strong><mark>char</mark>:</strong> Stores a single Unicode character (e.g., 'A', '1',
                                '$'). Enclosed in single quotes. <strong>Size: 2 bytes (16 bits)</strong>. Default
                                value: `'\u0000'` (null character).</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Non-Primitive (Reference) Types:</strong> Also known as reference types, these do not
                        store the actual data values directly but rather <b>references (memory addresses)</b> to the
                        objects in memory. They are created by the programmer or provided by Java's API.
                        <ul>
                            <li><strong><mark>String</mark>:</strong> Represents a sequence of characters. Immutable in
                                Java.</li>
                            <li><strong><mark>Arrays</mark>:</strong> Store multiple values of the same type in a
                                contiguous memory
                                block.</li>
                            <li><strong><mark>Classes</mark>:</strong> User-defined blueprints for objects (e.g.,
                                `Product`, `User`).
                            </li>
                            <li><strong><mark>Interfaces</mark>:</strong> Define a contract of methods that a class must
                                implement.
                            </li>
                        </ul>
                        <div class="highlight">
                            <p><strong>Note: </strong>The size of non-primitive types is not fixed; it depends on the
                                size of the objects they
                                refer to, which can vary. The reference itself typically takes up 4 or 8 bytes depending
                                on
                                the JVM architecture (32-bit or 64-bit).</p>
                        </div>
                    </li>
                </ul>

                <h4>Operators:</h4>
                <p>Operators are special symbols used to perform operations on variables and values. They are
                    categorized based on the type of operation they perform:</p>
                <ul>
                    <li>
                        <strong>Arithmetic Operators:</strong> Perform mathematical calculations.
                        <ul>
                            <li>`+` (Addition)</li>
                            <li>`-` (Subtraction)</li>
                            <li>`*` (Multiplication)</li>
                            <li>`/` (Division)</li>
                            <li>`%` (Modulus - remainder of division)</li>
                            <li>`++` (Increment - increases value by 1)</li>
                            <li>`--` (Decrement - decreases value by 1)</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Assignment Operators:</strong> Used to assign values to variables.
                        <ul>
                            <li>`=` (Assignment)</li>
                            <li>`+=` (Add and assign)</li>
                            <li>`-=` (Subtract and assign)</li>
                            <li>`*=` (Multiply and assign)</li>
                            <li>`/=` (Divide and assign)</li>
                            <li>`%=` (Modulus and assign)</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Comparison (Relational) Operators:</strong> Used to compare two values and return a
                        `boolean` result (`true` or `false`).
                        <ul>
                            <li>`==` (Equal to)</li>
                            <li>`!=` (Not equal to)</li>
                            <li>`>` (Greater than)</li>
                            <li>`<` (Less than)</li>
                            <li>`>=` (Greater than or equal to)</li>
                            <li>`<=` (Less than or equal to)</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Logical Operators:</strong> Used to combine or negate boolean expressions.
                        <ul>
                            <li>`&&` (Logical AND - true if both operands are true)</li>
                            <li>`||` (Logical OR - true if at least one operand is true)</li>
                            <li>`!` (Logical NOT - inverts the boolean state)</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Bitwise Operators:</strong> Perform operations on individual bits of integer types.
                        (e.g., `&` (AND), `|` (OR), `^` (XOR), `~` (NOT), `<<` (Left Shift), `>>` (Right Shift), `>>>`
                            (Unsigned Right Shift)).
                    </li>
                    <li>
                        <strong>Ternary (Conditional) Operator:</strong> A shorthand for an `if-else` statement.
                        <ul>
                            <li>`condition ? expression_if_true : expression_if_false;`</li>
                        </ul>
                    </li>
                </ul>

                <pre><code>
// Variable declarations
int age = 25;
double salary = 50000.50;
boolean isEmployed = true;
char grade = 'A';
String name = "John Doe";

// Operators
int a = 10, b = 20;

// Arithmetic Operators
int sum = a + b;           // sum = 30
int difference = a - b;    // difference = -10
int product = a * b;       // product = 200
int quotient = b / a;      // quotient = 2
int remainder = b % a;     // remainder = 0
a++;                       // a is now 11
b--;                       // b is now 19

// Comparison Operators
boolean isEqual = (a == b);    // isEqual = false (11 == 19)
boolean isGreater = (a > b);   // isGreater = false (11 > 19)

// Logical Operators
boolean condition1 = (a > 10); // condition1 = true (11 > 10)
boolean condition2 = (b < 20); // condition2 = true (19 < 20)
boolean resultAND = (condition1 && condition2); // resultAND = true
boolean resultOR = (condition1 || condition2);  // resultOR = true
boolean resultNOT = !(condition1);              // resultNOT = false

// Assignment Operators
int x = 5;
x += 3; // x is now 8 (x = x + 3)

// Ternary Operator
String status = (age >= 18) ? "Adult" : "Minor"; // status = "Adult"
    </code></pre>

                <hr>

                <h3>2. Conditional Statements</h3>
                <p><strong>Conditional statements</strong> (also known as <b>control flow statements</b>) are
                    fundamental programming constructs that allow you to control the <b>flow of program execution</b>
                    based on whether a specified condition evaluates to <mark>true</mark> or <mark>false</mark>. They
                    enable your programs to make decisions, execute different blocks of code under different
                    circumstances, and respond dynamically to varying inputs or states. This decision-making capability
                    is what makes programs intelligent and interactive.</p>

                <h4>Types of Conditional Statements in Java:</h4>

                <h4>a. If Statement</h4>
                <p>The <strong><mark>if</mark> statement</strong> is the most basic conditional statement. It executes a
                    block of code only if a specified boolean condition is <mark>true</mark>. If the condition is
                    <mark>false</mark>, the code block inside the `if` statement is skipped, and the program continues
                    execution after the `if` block.
                </p>
                <pre><code>
// If statement
int age = 25;
if (age >= 18) {
    System.out.println("Adult"); // This will be executed
}

int temperature = 10;
if (temperature > 25) {
    System.out.println("It's hot!"); // This will NOT be executed
}
    </code></pre>

                <h4>b. If-else Statement</h4>
                <p>The <strong><mark>if-else</mark> statement</strong> provides an alternative path of execution when
                    the `if` condition is <mark>false</mark>. If the condition in the <mark>`if</mark>` block is
                    <mark>true</mark>,
                    its code is executed. Otherwise (<mark>else</mark>), the code block associated with the `else` part
                    is executed. Exactly one of the two blocks will always execute.
                </p>
                <pre><code>
// If-else
int score = 75;
if (score >= 60) {
    System.out.println("Pass"); // This will be executed
} else {
    System.out.println("Fail");
}

int temperature = 5;
if (temperature > 25) {
    System.out.println("It's hot!");
} else {
    System.out.println("It's not hot!"); // This will be executed
}
    </code></pre>

                <h4>c. If-else If (Ladder If-else) Statement</h4>
                <p>The <strong><mark>if-else if ladder</mark></strong> (also known as the "else if" ladder) is used when
                    you need to test multiple conditions sequentially. The program evaluates conditions from top to
                    bottom. As soon as a condition evaluates to <mark>true</mark>, its corresponding code block is
                    executed, and the rest of the ladder is skipped. If none of the `if` or `else if` conditions are
                    met, the final `else` block (if present) is executed.</p>
                <pre><code>
public class IfElseLadderExample {
    public static void main(String[] args) {
        int score = 75;

        // Ladder if-else
        if (score >= 90) {
            System.out.println("Grade A");
        } else if (score >= 80) {
            System.out.println("Grade B");
        } else if (score >= 70) { // This condition (75 >= 70) is true
            System.out.println("Grade C"); // This will be executed
        } else {
            System.out.println("Grade D");
        }

        // Another example: Day of the week
        int dayOfWeek = 3; // Wednesday
        if (dayOfWeek == 1) {
            System.out.println("Monday");
        } else if (dayOfWeek == 2) {
            System.out.println("Tuesday");
        } else if (dayOfWeek == 3) {
            System.out.println("Wednesday"); // This will be executed
        } else {
            System.out.println("Another day");
        }
    }
}
    </code></pre>

                <h4>d. Nested If-else Statement</h4>
                <p>A <strong>nested <mark>if-else</mark> statement</strong> is an `if` or `if-else` statement placed
                    inside another `if` or `else` block. This allows for checking multiple layers of conditions, where
                    an inner condition is only relevant if an outer condition is met. While powerful, excessive nesting
                    can make code harder to read and maintain, so alternatives like logical operators (`&&`, `||`) or
                    refactoring should be considered for complex scenarios.</p>
                <pre><code>
public class NestedIfElseExample {
    public static void main(String[] args) {
        int age = 20;
        boolean hasLicense = true;

        if (age >= 18) { // Outer condition: Is age sufficient?
            if (hasLicense) { // Inner condition: Does person have a license?
                System.out.println("Eligible to drive"); // This will be executed
            } else {
                System.out.println("Not eligible to drive without a license");
            }
        } else {
            System.out.println("Not eligible to drive due to age");
        }

        // Example with stricter eligibility
        int creditScore = 700;
        boolean hasJob = true;

        if (creditScore >= 650) {
            if (hasJob) {
                System.out.println("Eligible for loan approval.");
            } else {
                System.out.println("Requires a job for loan approval.");
            }
        } else {
            System.out.println("Credit score too low for loan approval.");
        }
    }
}
    </code></pre>

                <h4>e. Switch Statement</h4>
                <p>The <strong><mark>switch</mark> statement</strong> is used for selecting one of many code blocks to
                    be executed. It evaluates an expression and executes the code block associated with the matching
                    `case` label. It's often a cleaner alternative to a long `if-else if` ladder when dealing with a
                    single variable that can have many distinct constant values. The expression in a `switch` can be a
                    `byte`, `short`, `char`, `int`, `enum` (since Java 5), `String` (since Java 7), or wrapper types
                    (`Byte`, `Short`, `Integer`, `Character`).</p>
                <ul>
                    <li>Each `case` label must be a unique constant value.</li>
                    <li>The <strong><mark>break</mark></strong> keyword is crucial; it terminates the switch statement
                        once a match is found and prevents "fall-through" to the next `case`.</li>
                    <li>The <strong><mark>default</mark></strong> keyword is optional and specifies the code to run if
                        no `case` match is found.</li>
                </ul>
                <pre><code>
// Switch case
int day = 2;
switch (day) {
    case 1:
        System.out.println("Monday");
        break;
    case 2: // Matches 'day' value of 2
        System.out.println("Tuesday"); // This will be executed
        break; // Exits the switch statement
    case 3:
        System.out.println("Wednesday");
        break;
    default:
        System.out.println("Other day");
}

// Example with String (Java 7+)
String trafficLight = "GREEN";
switch (trafficLight) {
    case "RED":
        System.out.println("STOP!");
        break;
    case "YELLOW":
        System.out.println("PREPARE TO STOP!");
        break;
    case "GREEN":
        System.out.println("GO!"); // This will be executed
        break;
    default:
        System.out.println("Invalid light state.");
}
    </code></pre>
                <div class="highlight">
                    <p></p><strong>Note: </strong>
                    For more modern Java versions (Java 12+), <strong>Switch Expressions</strong> offer a more concise
                    and powerful way to handle switch logic, allowing `switch` to return a value and avoiding
                    fall-through by default. This was discussed in the Java 17 features module.</p>
                </div>

                <h4>Flow Control Keywords: `break` and `continue`</h4>
                <p>Beyond conditional statements, Java provides keywords that alter the normal sequential flow of
                    execution, especially within loops or `switch` statements.</p>

                <h4>f. `break` Statement</h4>
                <p>The <strong><mark>break;</mark> statement</strong> is used to <b>terminate the current loop or
                        `switch`
                        statement immediately</b>. When a `break` is encountered, the program flow jumps to the
                    statement
                    immediately following the loop or `switch` block. It is commonly used to exit a loop prematurely
                    when a certain condition is met, or to prevent fall-through in `switch` cases (as shown in the
                    `switch` examples above).</p>
                <pre><code>
// Using break in a loop
for (int i = 1; i <= 10; i++) {
    if (i == 5) {
        System.out.println("Reached 5, breaking loop.");
        break; // Loop terminates when i is 5
    }
    System.out.println("Current number: " + i);
}
// Output:
// Current number: 1
// Current number: 2
// Current number: 3
// Current number: 4
// Reached 5, breaking loop.
    </code></pre>

                <h4>g. `continue` Statement</h4>
                <p>The <strong><mark>continue;</mark> statement</strong> is used to <b>skip the rest of the current
                        iteration of a loop and proceed to the next iteration</b>. When a `continue` is encountered, the
                    loop's body is immediately terminated for that specific iteration, and the loop control
                    (increment/decrement part in `for` loops, condition check in `while`/`do-while` loops) is executed,
                    potentially starting the next iteration.</p>
                <pre><code>
// Using continue in a loop
for (int i = 1; i <= 5; i++) {
    if (i == 3) {
        System.out.println("Skipping number 3.");
        continue; // Skips printing 3 and proceeds to next iteration
    }
    System.out.println("Current number: " + i);
}
// Output:
// Current number: 1
// Current number: 2
// Skipping number 3.
// Current number: 4
// Current number: 5
    </code></pre>

                <hr>
                <h3>3. Looping Statements</h3>
                <p><strong>Looping statements</strong> (also known as <b>iteration statements or repetition
                        statements</b>) are
                    fundamental control flow constructs that allow a block of code to be **repeatedly executed** as long
                    as a certain condition remains true. They are essential for tasks that involve processing
                    collections of data, performing repetitive calculations, or iterating through sequences. Loops
                    significantly reduce code redundancy and improve efficiency.</p>

                <h4>Types of Looping Statements in Java:</h4>

                <h4>a. For Loop</h4>
                <p>The <strong><mark>for</mark> loop</strong> is a control flow statement that iterates a part of the
                    program multiple times. It is ideal when you know the **exact number of iterations** beforehand. The
                    `for` loop consists of three main parts, typically declared within its parentheses:</p>
                <ol>
                    <li><strong>Initialization:</strong> Executed once when the loop starts, typically to declare and
                        initialize a loop control variable.</li>
                    <li><strong>Condition:</strong> Evaluated before each iteration. If `true`, the loop body executes;
                        if `false`, the loop terminates.</li>
                    <li><strong>Increment/Decrement (Iteration):</strong> Executed after each iteration of the loop
                        body, typically to update the loop control variable.</li>
                </ol>
                <pre><code>
// Basic For loop
for (int i = 0; i < 10; i++) { // i starts at 0, continues as long as i < 10, i increments by 1 each time
    System.out.println("Count: " + i);
}

// Output:
// Count: 0
// Count: 1
// ...
// Count: 9

// For loop in reverse
for (int i = 5; i > 0; i--) {
    System.out.println("Reverse Count: " + i);
}

// Output:
// Reverse Count: 5
// ...
// Reverse Count: 1
    </code></pre>

                <h4>b. While Loop</h4>
                <p>The <strong><mark>while</mark> loop</strong> is used when you don't know the exact number of
                    iterations beforehand, but rather want to repeat a block of code <b>as long as a specified boolean
                        condition remains `true`</b>. The condition is evaluated <b>before</b> each execution of the
                    loop body. If
                    the condition is initially `false`, the loop body will never execute.</p>
                <pre><code>
// While loop
int count = 0;
while (count < 5) { // Condition checked before each iteration
    System.out.println("While Count: " + count);
    count++; // Important: update the loop control variable to avoid infinite loop
}

// Output:
// While Count: 0
// While Count: 1
// While Count: 2
// While Count: 3
// While Count: 4
    </code></pre>

                <h4>c. Do-while Loop</h4>
                <p>The <strong><mark>do-while</mark> loop</strong> is similar to the `while` loop, but with one crucial
                    difference: the loop body is executed <b>at least once</b>, even if the condition is `false`
                    initially.
                    This is because the condition is evaluated <b>after</b> each execution of the loop body. It's
                    suitable
                    for scenarios where you need to perform an action at least once, then continue based on a condition
                    (e.g., getting user input until it's valid).</p>
                <pre><code>
// Do-while loop
int num = 1;
do {
    System.out.println("Do-While Num: " + num);
    num++;
} while (num <= 3); // Condition checked after first iteration and subsequent ones

// Output:
// Do-While Num: 1
// Do-While Num: 2
// Do-While Num: 3

// Example where do-while executes once
int x = 10;
do {
    System.out.println("This runs once because x <= 5 is false initially: " + x);
    x--;
} while (x <= 5);

// Output:
// This runs once because x <= 5 is false initially: 10
    </code></pre>

                <h4>d. For-each Loop (Enhanced For Loop)</h4>
                <p>The <strong><mark>for-each</mark> loop</strong> (also known as the enhanced `for` loop, introduced in
                    Java 5) provides a <b>simpler and more readable way to iterate over elements of arrays and
                        collections</b> (like `ArrayList`, `Set`, `Map` entries). Instead of managing an index or
                    iterator
                    manually, you directly declare a variable that will sequentially hold each element from the
                    collection during each iteration. It's perfect when you just need to access <b>each item</b> in a
                    sequence and don't need to know its specific index or position.</p>
                <pre><code>
Syntax:

for (DataType itemVariable : collectionOrArray) {
    // Code to execute for each 'itemVariable'
}
                                        </code></pre>

                <pre><code>
// For-each loop with an array of Strings
String[] fruits = {"Apple", "Banana", "Tomato"}; 

// Using a traditional for loop (managing index yourself)
System.out.println("--- Using Traditional For Loop ---");
for (int i = 0; i < fruits.length; i++) {
    String currentFruit = fruits[i]; // You have to use the index 'i' to get the fruit
    System.out.println("I picked up: " + currentFruit);
}

System.out.println("\n--- Using For-Each Loop ---");
// Using a for-each loop (Java handles getting each fruit for you)
for (String fruit : fruits) { // "For each String 'fruit' IN the 'fruits' array"
    System.out.println("I picked up: " + fruit); // 'fruit' directly holds the current item
}

// Output:

// --- Using Traditional For Loop ---
// I picked up: Apple
// I picked up: Banana
// I picked up: Tomato

// --- Using For-Each Loop ---
// I picked up: Apple
// I picked up: Banana
// I picked up: Tomato
    </code></pre>

                <h4>e. Nested Loops</h4>
                <p><strong>Nested loops</strong> involve placing one loop inside another. The inner loop completes all
                    of its iterations for each single iteration of the outer loop. Nested loops are commonly used for
                    tasks involving two-dimensional structures like matrices, grids, or generating patterns.</p>
                <pre><code>
// Nested loops for a multiplication table
// Outer loop for rows
for (int i = 1; i <= 3; i++) {
    // Inner loop for columns in each row
    for (int j = 1; j <= 3; j++) {
        System.out.print(i * j + " "); // Prints product followed by a space
    }
    System.out.println(); // Moves to the next line after each row is complete
}

// Output:
// 1 2 3
// 2 4 6
// 3 6 9
    </code></pre>

                <h4>Common Interview Pattern Programs (using Loops)</h4>
                <p>Pattern programs are frequently asked in interviews to assess a candidate's logical thinking,
                    understanding of nested loops, and ability to manipulate output. Here are some of the most common
                    ones:</p>

                <h4>1. Solid Square/Rectangle Pattern</h4>
                <p>Prints a solid square or rectangle of asterisks.</p>
                <pre><code>
/*
*****
*****
*****
*****
*/

public class SolidSquare {
    public static void main(String[] args) {
        int size = 5;
        for (int i = 0; i < size; i++) { // Outer loop for rows
            for (int j = 0; j < size; j++) { // Inner loop for columns
                System.out.print("*");
            }
            System.out.println(); // New line after each row
        }
    }
}
    </code></pre>

                <h4>2. Right-Angled Triangle Pattern (Half Pyramid)</h4>
                <p>Prints a right-angled triangle pattern where each row has one more asterisk than the previous.</p>
                <pre><code>
/*
*
**
***
****
*****
*/

public class RightTriangle {
    public static void main(String[] args) {
        int height = 5;
        for (int i = 1; i <= height; i++) { // Outer loop for rows (1 to height)
            for (int j = 1; j <= i; j++) { // Inner loop for columns (1 to current row number)
                System.out.print("*");
            }
            System.out.println();
        }
    }
}
    </code></pre>

                <h4>3. Inverted Right-Angled Triangle Pattern (Inverted Half Pyramid)</h4>
                <p>Prints an inverted right-angled triangle.</p>
                <pre><code>
/*
*****
****
***
**
*
*/

public class InvertedRightTriangle {
    public static void main(String[] args) {
        int height = 5;
        for (int i = height; i >= 1; i--) { // Outer loop for rows (height down to 1)
            for (int j = 1; j <= i; j++) { // Inner loop for columns (1 to current row number)
                System.out.print("*");
            }
            System.out.println();
        }
    }
}
    </code></pre>

                <h4>4. Full Pyramid (Isosceles Triangle)</h4>
                <p>Prints a symmetrical triangle. This often requires managing spaces before the asterisks.</p>
                <pre><code>
/*
    *
   ***
  *****
 *******
*********
*/

public class FullPyramid {
    public static void main(String[] args) {
        int height = 5;
        for (int i = 1; i <= height; i++) {
            // Print leading spaces
            for (int j = 1; j <= height - i; j++) {
                System.out.print(" ");
            }
            // Print asterisks
            for (int k = 1; k <= (2 * i - 1); k++) { // 1, 3, 5, 7, 9... asterisks
                System.out.print("*");
            }
            System.out.println();
        }
    }
}
    </code></pre>

                <h4>5. Number Patterns (e.g., Increasing Number Triangle)</h4>
                <p>Prints a triangle with increasing numbers.</p>
                <pre><code>
/*
1
12
123
1234
12345
*/

public class NumberTriangle {
    public static void main(String[] args) {
        int height = 5;
        for (int i = 1; i <= height; i++) { // Outer loop for rows
            for (int j = 1; j <= i; j++) { // Inner loop for numbers in current row
                System.out.print(j);
            }
            System.out.println();
        }
    }
}
    </code></pre>

                <h4>6. Floyd's Triangle</h4>
                <p>A right-angled triangle filled with consecutive numbers.</p>
                <pre><code>
/*
1
2 3
4 5 6
7 8 9 10
11 12 13 14 15
*/

public class FloydsTriangle {
    public static void main(String[] args) {
        int height = 5;
        int number = 1; // Counter for the numbers
        for (int i = 1; i <= height; i++) {
            for (int j = 1; j <= i; j++) {
                System.out.print(number + " ");
                number++;
            }
            System.out.println();
        }
    }
}
    </code></pre>

                <h4>7. Alphabet Pattern (Right-Angled Triangle of Letters)</h4>
                <p>Prints a triangle using letters, typically starting from 'A' and incrementing across rows/columns.
                </p>
                <pre><code>
/*
A
A B
A B C
A B C D
A B C D E
*/

public class AlphabetTriangle {
    public static void main(String[] args) {
        int height = 5;
        // The ASCII value of 'A' is 65
        for (int i = 0; i < height; i++) { // Outer loop for rows (0 to height-1)
            for (int j = 0; j <= i; j++) { // Inner loop for columns
                // Convert integer (65 + j) back to char
                System.out.print((char)('A' + j) + " ");
            }
            System.out.println();
        }
    }
}
    </code></pre>
                <div class="highlight">
                    <p><strong>Note: </strong>Mastering these looping constructs and basic pattern programs is crucial
                        for building logical
                        thinking and problem-solving skills in Java programming.</p>
                </div>

                <hr>

                <h3>4. Functions (Methods)</h3>

                <p>Imagine you have a specific task you do over and over again, like making a cup of coffee. Instead of
                    writing down all the steps ("get mug," "add coffee," "add hot water") every single time you want
                    coffee, wouldn't it be easier to just say "make coffee"?</p>

                <p>That's exactly what <strong>functions</strong> (or <strong>methods</strong> in some programming
                    languages like Java, which is what your examples use) are! They are <strong>reusable blocks of code
                        that perform specific tasks.</strong></p>

                <p>Think of them like mini-programs or recipes within your main program.</p>

                <h4>Why are Functions So Awesome?</h4>
                <ol>
                    <li>
                        <strong>Reusability (Don't Repeat Yourself - DRY principle!):</strong>
                        Once you've written a function to do something, you can call it (use it) as many times as you
                        want without writing the code again. This saves a lot of time and effort.
                    </li>
                    <li>
                        <strong>Organization:</strong>
                        Functions help you break down a big, complex problem into smaller, manageable chunks. This makes
                        your code easier to read, understand, and debug.
                    </li>
                    <li>
                        <strong>Readability:</strong>
                        Instead of a long, confusing list of instructions, you can have descriptive function names that
                        tell you what a piece of code does at a glance.
                    </li>
                    <li>
                        <strong>Easier to Debug:</strong>
                        If there's a problem, you often only need to look at the specific function that's causing the
                        issue, not your entire program.
                    </li>
                </ol>

                <h4>Anatomy of a Function (Method) - Let's look at your examples!</h4>

                <h4>1. Method with Parameters and a Return Value</h4>
                <p>This is the most common type of function: it takes some input (parameters) and gives back a result
                    (return value).</p>
                <pre><code>
// Method declaration: Takes two integers, returns their sum as an integer
public static int add(int a, int b) {
    return a + b;
}
    </code></pre>

                <p>Here's what each part means:</p>
                <ul>
                    <li><strong><mark>public</mark></strong>: An access modifier, meaning this method can be accessed
                        from any other class. For beginners, just include it.</li>
                    <li><strong><mark>static</mark></strong>: Means the method belongs to the class itself, not to a
                        specific object. Again, just include it for now.</li>
                    <li>
                        <strong><mark>int</mark></strong>: This is the <strong>return type</strong>. It specifies the
                        type of data the function will send back after it completes its task. Here, it's an integer.
                        <p class="analogy"><strong>Analogy:</strong> If you
                            ask a cashier "How much do I owe?", they <em>return</em> a number (the total amount).</p>

                    </li>
                    <li><strong><mark>add</mark></strong> : This is the <strong>name</strong> of the method. Choose a
                        name that clearly describes its purpose.</li>
                    <li>
                        <strong><mark>(int a, int b)</mark></strong> : These are the <strong>parameters</strong>. They
                        are variables that act as placeholders for the values the method needs to perform its operation.
                        <ul>
                            <li><mark>int a</mark> : An integer parameter named 'a'.</li>
                            <li><mark>int b</mark> : An integer parameter named 'b'.</li>
                        </ul>

                        <p class="analogy"><strong>Analogy:</strong> To make
                            a cake, you need ingredients like "flour" and "sugar" as parameters.</p>
                    </li>

                    <li><strong><mark>{ ... }</mark></strong> : This defines the <strong>method body</strong>,
                        containing
                        the actual code that performs the task.</li>
                    <li><strong><mark>return a + b;</mark></strong> : The <strong>return statement</strong>. It sends
                        the
                        calculated value back to the place where the method was called. A method with a
                        non-<mark>void</mark> return type <strong>must</strong> have a `return` statement.</li>
                </ul>

                <h4>2. Method with a `void` Return Type (Performs an Action, No Return Value)</h4>
                <p>Sometimes, a method just needs to do something, like display information or save data, without
                    producing a result that needs to be used by other parts of the program.</p>
                <pre><code>
// Method with void return type: Takes a String, prints it, returns nothing
public static void printMessage(String message) {
    System.out.println(message);
}
    </code></pre>

                <ul>
                    <li><strong><mark>void</mark></strong> : This signifies that the method <strong>does not return any
                            value</strong>. It simply performs an action.
                        <p class="analogy"><strong>Analogy:</strong> If you
                            tell a robot "Clean the room!", it performs the action but doesn't hand you anything back.
                        </p>
                    </li>
                    <li><strong><mark>printMessage(String message)</mark></strong> : This method takes one parameter, a
                        <mark>String</mark> called <mark>message</mark>.
                    </li>
                    <li><strong><mark>System.out.println(message);</mark></strong>: This line within the method's body
                        prints the `message` to the console. No `return` statement is used because the method's purpose
                        is to display, not to calculate and return a value.</li>
                </ul>

                <h4>3. Method Overloading: Same Name, Different Parameters</h4>
                <p>Method overloading allows you to define multiple methods within the same class that have the
                    <strong>same name</strong> but different <strong>parameter lists</strong> (different number of
                    parameters, different types of parameters, or different order of parameters).
                </p>
                <pre><code>
// Method overloading: Multiplies two integers
public static int multiply(int a, int b) {
    return a * b;
}

// Another overloaded method: Multiplies two double (decimal) numbers
public static double multiply(double a, double b) {
    return a * b;
}
    </code></pre>

                <ul>
                    <li><strong>Purpose:</strong> It makes your code more intuitive. You can use a common, logical name
                        for similar operations that work with different data types.</li>
                    <li><strong>How it works:</strong> When you call an overloaded method, the Java compiler looks at
                        the number and types of arguments you provide in the call. It then matches these arguments to
                        the most appropriate method signature (name + parameter list) and executes that specific
                        version.
                        <ul>
                            <li>Calling <mark>multiply(7, 3);</mark> would execute the
                                <mark>int multiply(int a, int b)</mark> version.
                            </li>
                            <li>Calling <mark>multiply(2.5, 4.0);</mark> would execute the
                                <mark>double multiply(double a, double b)</mark> version.
                            </li>
                        </ul>
                    </li>
                </ul>

                <h4>4. Method with No Parameters and a Return Value</h4>
                <p>Some functions don't need any external input to do their job, but they still produce a result.</p>
                <pre><code>
// Method with no parameters, returns a fixed value
public static String getAppName() {
    return "My Awesome App";
}
    </code></pre>
                <ul>
                    <li><strong><mark>()</mark></strong> : The empty parentheses indicate that this method takes no
                        parameters.</li>
                    <li><strong><mark>String</mark></strong> : This method returns a `String` (text) value.</li>
                    <li><strong><mark>return "My Awesome App";</mark></strong> : It simply returns a predefined string.
                        This could also be a result of an internal calculation or data retrieval that doesn't depend on
                        external input.</li>
                </ul>

                <h4>5. Method with No Parameters and No Return Value (`void`)</h4>
                <p>This type of method performs an action that requires no specific input and also doesn't produce any
                    value to be used elsewhere. It just does something internally.</p>
                <pre><code>
// Method with no parameters, returns nothing
public static void displayWelcomeMessage() {
    System.out.println("Welcome to the program!");
    System.out.println("Enjoy your experience.");
}
    </code></pre>
                <ul>
                    <li><strong><mark>()</mark></strong> : No parameters needed for this action.</li>
                    <li><strong><mark>void</mark></strong> : The method doesn't return any value.</li>
                    <li>Inside the body, it performs actions (printing messages) without needing external data.</li>
                </ul>


                <h4>How to Use (Call) Functions</h4>

                <p>To make a function actually do its job, you need to "call" or "invoke" it from another part of your
                    code (usually from your `main` method, which is the starting point of most Java programs).</p>

                <p>Let's imagine you have the functions defined as above. Here's how you would call them:</p>

                <pre><code>
public class MyProgram {
    public static void main(String[] args) {
        // Calling the 'add' function
        int sum = add(10, 5); // Arguments 10 and 5 are passed. Function returns 15.
        System.out.println("The sum is: " + sum); // Expected Output: The sum is: 15

        // Calling the 'printMessage' function
        printMessage("Hello, functions are fun!"); // Argument "Hello, functions are fun!" is passed. Function prints it.
                                                   // Expected Output: Hello, functions are fun!

        // Calling the 'multiply' (int) overloaded function
        int productInt = multiply(7, 3); // Calls the int version of multiply.
        System.out.println("Integer product: " + productInt); // Expected Output: Integer product: 21

        // Calling the 'multiply' (double) overloaded function
        double productDouble = multiply(2.5, 4.0); // Calls the double version of multiply.
        System.out.println("Double product: " + productDouble); // Expected Output: Double product: 10.0

        // Calling the 'getAppName' function
        String appName = getAppName(); // Function returns "My Awesome App".
        System.out.println("Application Name: " + appName); // Expected Output: Application Name: My Awesome App

        // Calling the 'displayWelcomeMessage' function
        displayWelcomeMessage(); // Function performs actions (printing messages) directly.
        // Expected Output:
        // Welcome to the program!
        // Enjoy your experience.
    }

    // --- Function Definitions (typically placed within the class, but outside of main) ---

    // Method with parameters and a return value
    public static int add(int a, int b) {
        return a + b;
    }

    // Method with void return type
    public static void printMessage(String message) {
        System.out.println(message);
    }

    // Method overloading (for integers)
    public static int multiply(int a, int b) {
        return a * b;
    }

    // Method overloading (for decimal numbers)
    public static double multiply(double a, double b) {
        return a * b;
    }

    // Method with no parameters and a return value
    public static String getAppName() {
        return "My Awesome App";
    }

    // Method with no parameters and no return value (void)
    public static void displayWelcomeMessage() {
        System.out.println("Welcome to the program!");
        System.out.println("Enjoy your experience.");
    }
}
    </code></pre>

                <h4>Quick Summary</h4>
                <ul>
                    <li><strong>Functions are like mini-programs that do specific jobs.</strong></li>
                    <li>They help you <strong>reuse code</strong>, keep it <strong>organized</strong>, and make it
                        <strong>easier to understand</strong>.
                    </li>
                    <li>They can <strong>take in information</strong> (parameters) and <strong>give back a
                            result</strong> (return type).</li>
                    <li>If a function doesn't give back a result, its return type is <mark>void</mark>.</li>
                    <li>You can have functions with the same name if they take different types or numbers of parameters
                        (<strong>Method Overloading</strong>).</li>
                    <li>Functions can have:
                        <ul>
                            <li>Parameters and a return value.</li>
                            <li>Parameters and no return value (<mark>void</mark>).</li>
                            <li>No parameters and a return value.</li>
                            <li>No parameters and no return value (<mark>void</mark>).</li>
                        </ul>
                    </li>
                    <li>To make a function run, you <strong>call</strong> it by its name, providing any necessary
                        arguments.</li>
                </ul>

                <div class="highlight">
                    <p><strong>Note: </strong>Functions are fundamental to writing efficient, maintainable, and readable
                        code. They enable breaking down complex
                        tasks into smaller, reusable units, which simplifies development and debugging. This structured
                        approach
                        significantly improves code clarity and long-term manageability.</p>
                </div>

                <hr>

                <h3>5. Arrays</h3>

                <p>Imagine you've got a list of similar things, like student grades or daily temperatures. Instead of
                    creating a separate variable for each one (like `grade1`, `grade2`, `tempMonday`, `tempTuesday`),
                    wouldn't it be way easier to put them all into one single, organized container?</p>

                <p>That's exactly what an <strong>Array</strong> is in programming! It's like a special variable that
                    can <strong>store many values of the same type</strong> (like all whole numbers, or all pieces of
                    text) in one neat spot.</p>

                <p>Think of an array as a <strong>shoe rack</strong> where each slot can hold one shoe. All the shoes on
                    that rack are for the same type of foot (e.g., all sneakers, not a mix of sneakers and flip-flops).
                </p>

                <h4>Why Use Arrays? (They Make Coding Much Better!)</h4>
                <ol>
                    <li>
                        <strong>Organized Storage:</strong> Arrays help you keep related data together in a tidy,
                        ordered way.
                    </li>
                    <li>
                        <strong>Efficient Handling:</strong> It's super easy to work with many items at once. You can
                        tell the computer to do something to "every item in this array" without writing a lot of
                        repetitive code.
                    </li>
                    <li>
                        <strong>Code Clarity:</strong> Using arrays makes your code cleaner and easier to understand
                        because you're managing collections of data simply.
                    </li>
                    <li>
                        <strong>Fixed Size (A Key Point for Java):</strong> When you create an array in Java, you decide
                        how many slots it'll have, and that number can't change later. If you need more space, you'd
                        typically create a new, bigger array and move your data over.
                    </li>
                </ol>

                <h4>How Arrays Work & Examples in a Program</h4>

                <p>Arrays store items in numbered compartments. This "compartment number" is called an
                    <strong>index</strong>, and it always starts counting from <strong>0</strong>.
                </p>

                <h4>1. One-Dimensional (1D) Arrays: Simple Lists</h4>
                <p>A 1D array is like a single row of compartments, or a straightforward list of items.</p>
                <pre><code>
// This is a complete Java program demonstrating arrays
public class ArrayExamples {
    public static void main(String[] args) {

        System.out.println("--- 1D Array Examples (Simple Lists) ---");

        // Example 1: Storing daily high temperatures for a week (int values)
        // We list the temperatures directly. Java counts them and sets the size.
        int[] dailyTemperatures = {28, 30, 29, 31, 32, 27, 26};
        // This array has 7 slots:
        // dailyTemperatures[0] is 28 (Monday's temp)
        // dailyTemperatures[1] is 30 (Tuesday's temp)
        // ...
        // dailyTemperatures[6] is 26 (Sunday's temp)

        // Example 2: Storing names of your favorite fruits (String values)
        // This array has 4 slots for text.
        String[] favoriteFruits = {"Apple", "Banana", "Cherry", "Date"};
        // favoriteFruits[0] is "Apple"
        // favoriteFruits[1] is "Banana"
        // ...

        // Example 3: Creating an empty list for 5 student scores (int values)
        // We tell Java to create 5 empty slots. For 'int', Java puts 0 in empty slots.
        int[] studentScores = new int[5];
        // Now, studentScores[0] through studentScores[4] are all 0.
        // We can fill them later!

        // --- How to Get & Change Items in a 1D Array ---
        // Use the compartment number (index) in square brackets []

        System.out.println("\n--- Accessing & Modifying 1D Arrays ---");

        // Get the temperature for Wednesday (it's in the 3rd slot, so index is 2)
        System.out.println("Wednesday's temperature: " + dailyTemperatures[2]); // Output: 29

        // Change the score of the 5th student (it's in the 5th slot, so index is 4)
        studentScores[4] = 85; // Put 85 into the 5th slot
        System.out.println("Score of 5th student: " + studentScores[4]); // Output: 85

        // Get your last favorite fruit (if there are 4 fruits, the last is at index 3)
        System.out.println("My last favorite fruit: " + favoriteFruits[3]); // Output: Date

        // Important: Trying to get a slot that doesn't exist (like dailyTemperatures[7])
        // will cause an error (ArrayIndexOutOfBoundsException)!

        System.out.println("--- End of 1D Array Examples ---\n");
    }
}
    </code></pre>

                <h4>What the Code Means (Simplified):</h4>
                <ul>
                    <li>In Example 1, we make a list <strong>dailyTemperatures</strong> and immediately fill it. The
                        first temperature (`28`) is at slot <strong>0</strong>, the second (`30`) at slot
                        <strong>1</strong>, and so on.
                    </li>
                    <li>In Example 2, we make a list <strong>favoriteFruits</strong> for text. "Apple" is at slot
                        <strong>0</strong>, "Banana" at slot <strong>1</strong>.
                    </li>
                    <li>In Example 3, we make an empty list <strong>studentScores</strong> with 5 slots. Java
                        automatically puts `0` in each slot because it's a number array. We can then put real scores in
                        later, like `studentScores[4] = 85;`.</li>
                    <li>To <strong>get</strong> a value, you say the array name followed by
                        <strong>[slot_number]</strong>.
                    </li>
                    <li>To <strong>change</strong> a value, you say the array name <strong>[slot_number] =
                            new_value;</strong>.</li>
                </ul>

                <h4>2. Two-Dimensional (2D) Arrays: Grids or Tables</h4>
                <p>A 2D array is like a grid, a table, or a spreadsheet. It has both rows and columns, like a
                    checkerboard or a game board. You need <strong>two</strong> numbers to find an item: one for the
                    row, and one for the column.</p>
                <pre><code>
// This is part of the same Java program, extending the main method
public class ArrayExamples {
    public static void main(String[] args) {
        // ... (previous 1D array examples) ...

        System.out.println("\n--- 2D Array Examples (Grids/Tables) ---");

        // Example 1: A simple 3x3 tic-tac-toe board (0=empty, 1=Player X, 2=Player O)
        // This is a grid with 3 rows and 3 columns.
        int[][] ticTacToeBoard = {
            {0, 1, 0}, // Row 0: 0, 1, 0
            {1, 2, 0}, // Row 1: 1, 2, 0
            {0, 0, 1}  // Row 2: 0, 0, 1
        };
        /*
          Conceptually:
                  Col 0   Col 1   Col 2
        Row 0:      0       1       0
        Row 1:      1       2       0
        Row 2:      0       0       1
        */

        // Example 2: Scores of 2 teams in 3 different matches
        // This is a table with 2 rows (for 2 teams) and 3 columns (for 3 matches).
        int[][] teamScores = {
            {100, 120, 95}, // Team A's scores (Row 0)
            {80, 110, 130}  // Team B's scores (Row 1)
        };

        // Example 3: Creating an empty 4x5 grid for a maze game (4 rows, 5 columns)
        // Java creates all slots and fills them with 0s for 'int'.
        int[][] maze = new int[4][5];


        // --- How to Get & Change Items in a 2D Array ---
        // Use [row_number][column_number], both starting from 0

        System.out.println("\n--- Accessing & Modifying 2D Arrays ---");

        // Get the value in the middle of the tic-tac-toe board (Row 1, Column 1)
        System.out.println("Center of board: " + ticTacToeBoard[1][1]); // Output: 2

        // Change the score of Team B in their 3rd match (Team B is Row 1, 3rd match is Column 2)
        teamScores[1][2] = 140; // Change Team B's 3rd match score from 130 to 140
        System.out.println("Team B's new 3rd match score: " + teamScores[1][2]); // Output: 140

        // Set a 'wall' in the maze at Row 2, Column 3 (let's say 1 means a wall)
        maze[2][3] = 1;
        System.out.println("Maze spot (Row 2, Col 3) now: " + maze[2][3]); // Output: 1
    }
}
    </code></pre>

                <h4>What the Code Means (Simplified):</h4>
                <ul>
                    <li>In Example 1, <strong>ticTacToeBoard[1][1]</strong> means "go to the
                        <strong>ticTacToeBoard</strong> grid, find <strong>Row 1</strong>, then find <strong>Column
                            1</strong> within that row."
                    </li>
                    <li>In Example 2, <strong>teamScores[1][2]</strong> means "go to the <strong>teamScores</strong>
                        table, find <strong>Row 1</strong> (Team B), then find <strong>Column 2</strong> (their 3rd
                        match score)."</li>
                    <li>To <strong>get</strong> a value, you say <strong>arrayName[row_number][column_number]</strong>.
                    </li>
                    <li>To <strong>change</strong> a value, you say <strong>arrayName[row_number][column_number] =
                            new_value;</strong>.</li>
                    <li>Just like 1D arrays, if you use a row or column number that's out of bounds, your program will
                        crash!</li>
                </ul>

                <h4>Quick Recap of Arrays:</h4>
                <ul>
                    <li><strong>Arrays</strong> are containers that hold <strong>many items of the same type</strong>.
                    </li>
                    <li>Items are stored in numbered <strong>compartments</strong> called <strong>indexes</strong>,
                        starting from <strong>0</strong>.</li>
                    <li><strong>1D Arrays</strong> are simple lists (like a shopping list).</li>
                    <li><strong>2D Arrays</strong> are grids or tables (like a spreadsheet or game board), using both a
                        row and column index.</li>
                    <li>In Java, arrays have a <strong>fixed size</strong> once you create them.</li>
                    <li>They make your code more organized, efficient, and easier to read when dealing with collections
                        of data.</li>
                </ul>

                <div class="highlight">
                    <p><strong>Note: </strong>Arrays are a fundamental tool for organizing information in programming,
                        truly your <strong>Digital Storage Boxes</strong>!</p>
                </div>

                <hr>


                <h3>6. String & String Methods</h3>
                <p>In Java, the <code>String</code> class is a fundamental building block for handling sequences of
                    characters, essentially representing text data. It's one of the most frequently used classes in Java
                    programming, vital for everything from user input and messages to complex data structures like JSON
                    or XML. Java provides a rich set of built-in methods to manipulate, analyze, and combine these text
                    sequences efficiently.</p>

                <div class="highlight">
                    <p><strong>A Fundamental Characteristic: Java Strings are Immutable</strong></p>
                    <p>This is a cornerstone concept: once a <code>String</code> object is created, its content cannot
                        be changed. Any operation that seems to modify a string (like converting to uppercase or
                        replacing characters) doesn't alter the original string. Instead, it creates a <b>brand-new
                            <code>String</code> object</b> containing the result, leaving the original string untouched
                        in memory. This immutability offers significant benefits in terms of safety (especially in
                        multi-threaded environments, as their state never changes) and efficiency (their hash code can
                        be cached, making them excellent keys in hash-based collections like <code>HashMap</code>).</p>
                </div>

                <pre><code>
String str = "Hello World"; // 'str' is a String variable holding the text "Hello World"

// Common String methods: Essential tools for text manipulation
// (Refer to: https://www.w3schools.com/java/java_strings.asp)
int length = str.length();               // Returns the number of characters in the string.
String upper = str.toUpperCase();        // Converts all characters in the string to uppercase.
String lower = str.toLowerCase();        // Converts all characters in the string to lowercase.
char charAt = str.charAt(0);             // Returns the character at the specified index (position). Index starts from 0.
String substring = str.substring(0, 5);  // Extracts a part of the string. The substring starts at index 0 and extends to character at index 4 (exclusive of index 5).
boolean contains = str.contains("World"); // Checks if the string contains the specified sequence of characters. Returns true or false.
String replaced = str.replace("World", "Java"); // Replaces all occurrences of the target sequence ("World") with the replacement sequence ("Java").
    </code></pre>

                <h4>More Key String Methods and Important Concepts:</h4>
                <p>Let's dive deeper into additional, commonly used String methods and crucial concepts for
                    comprehensive understanding.</p>

                <div class="concept-box">
                    <h4>String Concatenation: Joining Text Together</h4>
                    <p>Concatenation is the process of combining two or more strings into a single string. Java offers
                        several ways to do this, each with its own advantages.</p>
                    <p>(Refer to: <a href="https://www.w3schools.com/java/java_strings_concat.asp"
                            target="_blank">W3Schools Java String Concatenation</a>)</p>
                    <ul>
                        <li><code><b>+</b></code> (Plus Operator): The most common and straightforward way to
                            concatenate strings. It's simple and readable for a few concatenations.</li>
                        <li><code><b>.concat(String str)</b></code>: A method of the <code>String</code> class that
                            appends the specified string to the end of the current string. It can be chained for
                            multiple concatenations.</li>
                        <li><code><b>String.format(String format, Object... args)</b></code>: A powerful method for
                            creating formatted strings by inserting values into placeholders. It's excellent for
                            building complex output where you want precise control over formatting (like number of
                            decimal places, padding, etc.).</li>
                        <li><code><b>StringBuilder / StringBuffer</b></code>: For building strings with many dynamic
                            changes (see section below for more details on these efficient alternatives).</li>
                    </ul>
                    <pre><code>
// Using the '+' operator
String firstName = "John";
String lastName = "Doe";
String fullName = firstName + " " + lastName; // Result: "John Doe"
System.out.println("Full Name (+ operator): " + fullName);

String message = "Hello, " + "Java " + 17 + "!"; // Numbers are automatically converted to strings
System.out.println("Message (+ operator): " + message); // Result: "Hello, Java 17!"

// Using .concat() method
String greeting = "Welcome".concat(" to").concat(" Java!");
System.out.println("Greeting (.concat()): " + greeting); // Result: "Welcome to Java!"

// Using String.format() for formatted output
String item = "Laptop";
double price = 1200.50;
int quantity = 2;
String orderSummary = String.format("You ordered %d %s(s) for a total of $%.2f.", quantity, item, (price * quantity));
System.out.println("Order Summary (String.format()): " + orderSummary);
// Result: You ordered 2 Laptop(s) for a total of $2401.00.

// Common String.format() placeholders:
// %s - String
// %d - decimal integer
// %f - floating-point number (e.g., %.2f for two decimal places)
// %b - boolean
// %c - character
        </code></pre>
                    <div class="highlight">
                        <p><strong>Performance Tip for Concatenation:</strong></p>
                        <p>While the `+` operator is convenient, for a large number of string concatenations (especially
                            inside loops), it can be inefficient due to the immutability of `String` objects. Each `+`
                            operation effectively creates a new `String` object. In such scenarios, `StringBuilder` (or
                            `StringBuffer` in multi-threaded contexts) is significantly more performant as it modifies a
                            single, mutable sequence of characters in memory.</p>
                    </div>
                </div>

                <div class="concept-box">
                    <h4>String and Numbers: Seamless Integration and Important Conversions</h4>
                    <p>Java handles the interaction between strings and numbers quite gracefully, often performing
                        automatic conversions. However, it's crucial to understand how these conversions work,
                        especially when converting strings to numbers, where specific methods and error handling are
                        required.</p>
                    <p>(Refer to: <a href="https://www.w3schools.com/java/java_strings_numbers.asp"
                            target="_blank">W3Schools Java Strings Numbers</a>)</p>
                    <ul>
                        <li><b>Number to String:</b>
                            <ul>
                                <li><b>Automatic Conversion:</b> When you concatenate a number with a string using the
                                    `+` operator, the number is automatically converted to its string representation.
                                    This is implicitly handled by the Java compiler.</li>
                                <li><code><b>String.valueOf(number)</b></code>: This is the explicit and recommended way
                                    to convert any primitive type (<code>int</code>, <code>double</code>,
                                    <code>boolean</code>, etc.) or object to its string representation. It's clear and
                                    versatile.
                                </li>
                            </ul>
                        </li>
                        <li><b>String to Number:</b>
                            <ul>
                                <li>To convert a string containing digits into a numeric type, you use the `parse`
                                    methods provided by Java's <a
                                        href="https://docs.oracle.com/javase/tutorial/java/data/numbers.html"
                                        target="_blank">Wrapper Classes</a> (e.g., `Integer`, `Double`).</li>
                                <li><code><b>Integer.parseInt(String str)</b></code>: Converts a string to an
                                    <code>int</code>.
                                </li>
                                <li><code><b>Double.parseDouble(String str)</b></code>: Converts a string to a
                                    <code>double</code>.
                                </li>
                                <li>Similar methods exist for `Long.parseLong()`, `Float.parseFloat()`, etc.</li>
                                <li><b>Important Error Handling:</b> These parsing methods will throw a
                                    <code><b>NumberFormatException</b></code> if the string does not contain a valid
                                    representation of the number type (e.g., trying to parse "abc" as an integer). You
                                    should always handle this exception using a `try-catch` block, especially when
                                    dealing with user input or data from external sources, to prevent your program from
                                    crashing.
                                </li>
                            </ul>
                        </li>
                    </ul>
                    <pre><code>
// Number to String Conversion
int age = 30;
String myAge = "My age is " + age; // Automatic conversion via concatenation
System.out.println(myAge); // Output: My age is 30

double price = 99.95;
String priceTag = String.valueOf(price); // Explicit conversion using valueOf()
System.out.println("Price: $" + priceTag); // Output: Price: $99.95

// String to Number Conversion
String strCount = "123";
int count = Integer.parseInt(strCount);
System.out.println("Parsed count: " + count); // Output: Parsed count: 123
System.out.println("Count doubled: " + (count * 2)); // Perform arithmetic: 246

String strTemp = "25.7";
double temperature = Double.parseDouble(strTemp);
System.out.println("Parsed temperature: " + temperature); // Output: Parsed temperature: 25.7

// Handling invalid conversions (Crucial for robust applications!)
String invalidNumber = "hello";
try {
    int value = Integer.parseInt(invalidNumber);
    System.out.println("Converted value: " + value);
} catch (NumberFormatException e) {
    System.err.println("Error: Could not convert '" + invalidNumber + "' to an integer. Invalid format.");
    // Output: Error: Could not convert 'hello' to an integer. Invalid format.
}
        </code></pre>
                </div>

                <div class="concept-box">
                    <h4>Special Characters and Escape Sequences in Strings</h4>
                    <p>Sometimes you need to include characters in your string that have a special meaning in Java, or
                        characters that are not directly printable (like a newline or a tab). To achieve this, you use
                        "escape sequences," which are combinations of a backslash (<code>\</code>) followed by a
                        specific character. The backslash tells the Java compiler to interpret the next character in a
                        special way, escaping its usual meaning.</p>
                    <p>(Refer to: <a href="https://www.w3schools.com/java/java_strings_specchars.asp"
                            target="_blank">W3Schools Java Special Characters</a>)</p>
                    <ul>
                        <li><code><b>\'</b></code>: Single quote (useful for character literals, or if your string was
                            defined using single quotes in some other context, though Java uses double quotes for
                            strings)</li>
                        <li><code><b>\"</b></code>: Double quote (to include a literal double quote within a
                            double-quoted string)</li>
                        <li><code><b>\\</b></code>: Backslash (to include a literal backslash character itself)</li>
                        <li><code><b>\n</b></code>: Newline (inserts a line break, moving subsequent text to the next
                            line)</li>
                        <li><code><b>\t</b></code>: Tab (inserts a horizontal tab space)</li>
                        <li><code><b>\b</b></code>: Backspace</li>
                        <li><code><b>\r</b></code>: Carriage Return (moves the cursor to the beginning of the current
                            line, often used with `\n` for Windows-style line endings)</li>
                        <li><code><b>\f</b></code>: Form Feed</li>
                    </ul>
                    <pre><code>
String quote = "He said, \"Java is awesome!\""; // Includes double quotes
System.out.println(quote); // Output: He said, "Java is awesome!"

String filePath = "C:\\Users\\Public\\Documents"; // Includes literal backslashes (common for Windows paths)
System.out.println(filePath); // Output: C:\Users\Public\Documents

String multiLine = "Line One.\nLine Two.\nLine Three."; // Uses newlines for line breaks
System.out.println(multiLine);
// Output:
// Line One.
// Line Two.
// Line Three.

String formattedOutput = "Name:\tAlice\nAge:\t30"; // Uses tabs and newlines for structured output
System.out.println(formattedOutput);
// Output:
// Name:  Alice
// Age:   30
        </code></pre>
                </div>

                ---

                <h3>String Builders: `StringBuffer` and `StringBuilder`</h3>
                <p>As discussed, standard Java <code>String</code> objects are immutable. While this has advantages, it
                    becomes inefficient when you need to perform numerous modifications to a string (e.g., building a
                    long string by appending many smaller pieces in a loop). In such cases, creating many intermediate
                    <code>String</code> objects can lead to performance degradation and increased memory consumption.
                </p>
                <p>To address this, Java provides two mutable (changeable) alternatives: <code>StringBuffer</code> and
                    <code>StringBuilder</code>. These classes allow you to modify the content of the string they hold
                    without creating new objects for each operation, making them highly efficient for dynamic string
                    construction.
                </p>

                <div class="highlight">
                    <p><strong>Historical Context of `StringBuffer` and `StringBuilder`:</strong></p>
                    <ul>
                        <li><code>StringBuffer</code> was introduced in Java 1.0 (the very first version of Java). It
                            was designed to provide a mutable sequence of characters to overcome the performance issues
                            of frequent <code>String</code> modifications. Its methods are <b>synchronized</b>.</li>
                        <li><code>StringBuilder</code> was introduced later in Java 1.5. It provides the same
                            functionality as <code>StringBuffer</code> but is <b>not synchronized</b>. This lack of
                            synchronization makes <code>StringBuilder</code> generally faster than
                            <code>StringBuffer</code> for string manipulation in single-threaded environments, as it
                            avoids the overhead of managing concurrent access.
                        </li>
                    </ul>
                </div>

                <div class="concept-box">
                    <h4>`StringBuffer` (Thread-Safe)</h4>
                    <p><code>StringBuffer</code> is designed for multi-threaded environments. All its public methods are
                        <b>synchronized</b>. This means that if multiple threads try to access and modify the same
                        <code>StringBuffer</code> instance simultaneously, only one thread can execute a method at a
                        time. This guarantees data consistency and prevents race conditions, but it introduces a
                        performance overhead due to the locking mechanism.
                    </p>
                    <pre><code>
// StringBuffer (thread-safe): Ideal for scenarios where multiple threads might modify the same string data concurrently.
StringBuffer sb = new StringBuffer("Hello"); // Initializes with "Hello"
System.out.println("StringBuffer initial: " + sb); // Output: StringBuffer initial: Hello

sb.append(" World");                     // Appends " World" to the existing content.
System.out.println("StringBuffer after append: " + sb); // Output: StringBuffer after append: Hello World

sb.insert(5, " Beautiful");             // Inserts " Beautiful" at index 5.
System.out.println("StringBuffer after insert: " + sb); // Output: StringBuffer after insert: Hello Beautiful World

sb.delete(5, 15);                       // Deletes characters from index 5 up to (but not including) 15
System.out.println("StringBuffer after delete: " + sb); // Output: StringBuffer after delete: Hello World"

sb.reverse();                           // Reverses the sequence of characters
System.out.println("StringBuffer after reverse: " + sb); // Output: StringBuffer after reverse: dlroW olleH
        </code></pre>
                </div>

                <div class="concept-box">
                    <h4>`StringBuilder` (Not Thread-Safe, Faster)</h4>
                    <p><code>StringBuilder</code> provides identical functionality to `StringBuffer` but is <b>not
                            synchronized</b>. This makes it faster and more efficient than `StringBuffer` when you are
                        performing string manipulations in a <b>single-threaded environment</b>. Since most common
                        applications don't involve multiple threads modifying the *exact same* string builder object
                        concurrently, <code>StringBuilder</code> is generally the preferred choice for building dynamic
                        strings.</p>
                    <p>(Refer to: <a href="https://www.geeksforgeeks.org/stringbuilder-class-in-java-with-examples/"
                            target="_blank">GeeksforGeeks StringBuilder</a>)</p>
                    <pre><code>
// StringBuilder (not thread-safe, faster): Preferred for single-threaded environments or when thread safety is handled externally.
StringBuilder builder = new StringBuilder(); // Initializes an empty builder
System.out.println("StringBuilder initial (empty): '" + builder + "'"); // Output: StringBuilder initial (empty): ''

builder.append("Java");                  // Appends "Java"
System.out.println("StringBuilder after first append: " + builder); // Output: StringBuilder after first append: Java

builder.append(" Programming");          // Appends " Programming"
System.out.println("StringBuilder after second append: " + builder); // Output: StringBuilder after second append: Java Programming

builder.insert(4, " is fun");           // Inserts " is fun" at index 4
System.out.println("StringBuilder after insert: " + builder); // Output: StringBuilder after insert: Java is fun Programming

String finalResult = builder.toString(); // Converts the StringBuilder content to an immutable String object.
System.out.println("Final String from StringBuilder: " + finalResult);
        </code></pre>
                </div>

                <h4>Choosing between `String`, `StringBuffer`, and `StringBuilder`: A Quick Guide</h4>
                <p>Making the right choice among these three classes is crucial for writing efficient and robust Java
                    code. Here's a summary to guide your decision:</p>

                <div class="concept-box">
                    <h4>`String`</h4>
                    <ul>
                        <li><b>When to use:</b>
                            <ul>
                                <li>For text that is constant or rarely changes.</li>
                                <li>When you need string literals (e.g., <code>"Hello"</code>).</li>
                                <li>For method parameters and return values.</li>
                                <li>As keys in <code>HashMap</code> or elements in <code>HashSet</code> due to
                                    immutability and cached hash codes.</li>
                            </ul>
                        </li>
                        <li><b>Pros:</b> Immutability ensures thread safety, high performance for hashing, clear and
                            easy to use for simple text.</li>
                        <li><b>Cons:</b> Inefficient for frequent modifications as each change creates a new object,
                            leading to potential performance and memory issues.</li>
                    </ul>
                </div>

                <div class="concept-box">
                    <h4>`StringBuilder`</h4>
                    <ul>
                        <li><b>When to use:</b>
                            <ul>
                                <li>When you need to perform many dynamic modifications (append, insert, delete,
                                    replace) to a string.</li>
                                <li><b>In a single-threaded environment</b> (e.g., within a single method where the
                                    string isn't shared across threads). This is the most common use case for building
                                    dynamic strings.</li>
                            </ul>
                        </li>
                        <li><b>Pros:</b> Mutable, highly efficient for dynamic string operations, significantly faster
                            than <code>StringBuffer</code> due to no synchronization overhead.</li>
                        <li><b>Cons:</b> <b>Not thread-safe.</b> Avoid using it when multiple threads might access and
                            modify the same instance concurrently without external synchronization.</li>
                    </ul>
                </div>

                <div class="concept-box">
                    <h4>`StringBuffer`</h4>
                    <ul>
                        <li><b>When to use:</b>
                            <ul>
                                <li>When you need to perform many dynamic modifications to a string.</li>
                                <li><b>In a multi-threaded environment</b> where multiple threads might access and
                                    modify the same string object concurrently.</li>
                            </ul>
                        </li>
                        <li><b>Pros:</b> Mutable, <b>thread-safe</b> (all its public methods are synchronized,
                            preventing data consistency issues in concurrent access).</li>
                        <li><b>Cons:</b> Slower than <code>StringBuilder</code> due to the overhead of synchronization.
                            If thread safety is not a concern, <code>StringBuilder</code> is the more performant choice.
                        </li>
                    </ul>
                </div>

                <p>By understanding these nuances and leveraging the appropriate class for your needs, you can write
                    more efficient, robust, and readable Java code for string manipulation.</p>




                <h3>7. Math Methods</h3>
                <p>In Java, the <code>java.lang.Math</code> class provides a comprehensive set of static methods for
                    performing common mathematical operations. You don't need to create an object of the
                    <code>Math</code> class to use its methods; you can directly call them using the class name itself
                    (e.g., <code>Math.methodName()</code>). This class includes methods for trigonometric functions,
                    exponential functions, logarithmic functions, and various other utility functions for numeric
                    manipulation.
                </p>

                <div class="highlight">
                    <p><strong>Key Characteristics of the `Math` Class:</strong></p>
                    <ul>
                        <li><b>Static Methods:</b> All methods in the <code>Math</code> class are <code>static</code>.
                            This means you call them directly on the class name (e.g., <code>Math.sqrt()</code>) without
                            needing to create an instance of <code>Math</code>.</li>
                        <li><b>Return Types:</b> Most methods return <code>double</code> values, even if the inputs are
                            integers. Be mindful of type casting if you need an integer result.</li>
                        <li><b>Final Class:</b> The <code>Math</code> class itself is <code>final</code>, meaning it
                            cannot be subclassed.</li>
                    </ul>
                </div>

                <pre><code>
// Common Math methods
double result1 = Math.pow(2, 3);       // 8.0  (2 raised to the power of 3)
double result2 = Math.sqrt(16);        // 4.0  (Square root of 16)
double result3 = Math.abs(-10);        // 10.0 (Absolute value of -10)
double result4 = Math.max(10, 20);     // 20.0 (Returns the larger of two numbers)
double result5 = Math.min(10, 20);     // 10.0 (Returns the smaller of two numbers)
double result6 = Math.random();        // Random double between 0.0 (inclusive) and 1.0 (exclusive)
double result7 = Math.ceil(4.3);       // 5.0  (Rounds up to the nearest whole number)
double result8 = Math.floor(4.7);      // 4.0  (Rounds down to the nearest whole number)
double result9 = Math.round(4.6);      // 5.0  (Rounds to the nearest long or int)
    </code></pre>

                <h4>Detailed Explanation of Common Math Methods:</h4>

                <div class="concept-box">
                    <h4>`Math.pow(double base, double exponent)`</h4>
                    <p>This method returns the value of the first argument `base` raised to the power of the second
                        argument `exponent` ($base^{exponent}$).</p>
                    <ul>
                        <li><b>Inputs:</b> Two <code>double</code> values.</li>
                        <li><b>Output:</b> A <code>double</code> value.</li>
                    </ul>
                    <pre><code>
// Example: Calculate 2 to the power of 3
double powerResult = Math.pow(2, 3);
System.out.println("2^3 = " + powerResult); // Output: 2^3 = 8.0

// Example: Calculate 9 to the power of 0.5 (square root)
double sqrtUsingPow = Math.pow(9, 0.5);
System.out.println("9^0.5 = " + sqrtUsingPow); // Output: 9^0.5 = 3.0
        </code></pre>
                </div>

                <div class="concept-box">
                    <h4>`Math.sqrt(double a)`</h4>
                    <p>This method returns the positive square root of a `double` value.</p>
                    <ul>
                        <li><b>Inputs:</b> A <code>double</code> value.</li>
                        <li><b>Output:</b> A <code>double</code> value. If the argument is negative, the result is `NaN`
                            (Not-a-Number).</li>
                    </ul>
                    <pre><code>
// Example: Square root of 25
double sqrtResult = Math.sqrt(25);
System.out.println("Square root of 25 = " + sqrtResult); // Output: Square root of 25 = 5.0

// Example: Square root of 2 (irrational number)
double sqrt2 = Math.sqrt(2);
System.out.println("Square root of 2 = " + sqrt2); // Output: Square root of 2 = 1.4142135623730951

// Example: Negative input
double sqrtNegative = Math.sqrt(-9);
System.out.println("Square root of -9 = " + sqrtNegative); // Output: Square root of -9 = NaN
        </code></pre>
                </div>

                <div class="concept-box">
                    <h4>`Math.abs(dataType a)`</h4>
                    <p>This method returns the absolute (positive) value of a number. It is overloaded to accept `int`,
                        `long`, `float`, and `double` arguments.</p>
                    <ul>
                        <li><b>Inputs:</b> An `int`, `long`, `float`, or `double` value.</li>
                        <li><b>Output:</b> The absolute value, with the same data type as the input.</li>
                    </ul>
                    <pre><code>
// Example: Absolute value of integers
int absInt = Math.abs(-5);
System.out.println("Absolute value of -5 = " + absInt); // Output: Absolute value of -5 = 5

// Example: Absolute value of doubles
double absDouble = Math.abs(-12.75);
System.out.println("Absolute value of -12.75 = " + absDouble); // Output: Absolute value of -12.75 = 12.75
        </code></pre>
                </div>

                <div class="concept-box">
                    <h4>`Math.max(dataType a, dataType b)`</h4>
                    <p>This method returns the greater of two numbers. It is overloaded to work with `int`, `long`,
                        `float`, and `double` arguments.</p>
                    <ul>
                        <li><b>Inputs:</b> Two numbers of the same data type.</li>
                        <li><b>Output:</b> The larger of the two numbers, with the same data type as the inputs.</li>
                    </ul>
                    <pre><code>
// Example: Max of two integers
int maxInt = Math.max(10, 25);
System.out.println("Max of 10 and 25 = " + maxInt); // Output: Max of 10 and 25 = 25

// Example: Max of two doubles
double maxDouble = Math.max(3.14, 2.71);
System.out.println("Max of 3.14 and 2.71 = " + maxDouble); // Output: Max of 3.14 and 2.71 = 3.14
        </code></pre>
                </div>

                <div class="concept-box">
                    <h4>`Math.min(dataType a, dataType b)`</h4>
                    <p>This method returns the smaller of two numbers. It is overloaded to work with `int`, `long`,
                        `float`, and `double` arguments.</p>
                    <ul>
                        <li><b>Inputs:</b> Two numbers of the same data type.</li>
                        <li><b>Output:</b> The smaller of the two numbers, with the same data type as the inputs.</li>
                    </ul>
                    <pre><code>
// Example: Min of two integers
int minInt = Math.min(10, 25);
System.out.println("Min of 10 and 25 = " + minInt); // Output: Min of 10 and 25 = 10

// Example: Min of two doubles
double minDouble = Math.min(3.14, 2.71);
System.out.println("Min of 3.14 and 2.71 = " + minDouble); // Output: Min of 3.14 and 2.71 = 2.71
        </code></pre>
                </div>

                <div class="concept-box">
                    <h4>`Math.random()`</h4>
                    <p>This method returns a pseudorandom `double` value greater than or equal to 0.0 and less than 1.0.
                        This is very useful for generating random numbers in simulations, games, or for various other
                        purposes.</p>
                    <ul>
                        <li><b>Inputs:</b> None.</li>
                        <li><b>Output:</b> A `double` value between 0.0 (inclusive) and 1.0 (exclusive).</li>
                    </ul>
                    <pre><code>
// Example: Generate a random double
double randomValue = Math.random();
System.out.println("Random double (0.0 to < 1.0): " + randomValue); // Output will vary, e.g., 0.789123...

// Example: Generate a random integer between 1 and 10 (inclusive)
// Formula: (int)(Math.random() * (max - min + 1)) + min
int min = 1;
int max = 10;
int randomInt = (int)(Math.random() * (max - min + 1)) + min;
System.out.println("Random integer (1 to 10): " + randomInt); // Output will vary, e.g., 7
        </code></pre>
                </div>

                <div class="concept-box">
                    <h4>Rounding Methods: `ceil()`, `floor()`, `round()`</h4>
                    <p>These methods are essential for handling decimal numbers and obtaining whole number
                        representations based on different rounding rules.</p>
                    <ul>
                        <li><code><b>Math.ceil(double a)</b></code>: Returns the smallest (closest to negative infinity)
                            <code>double</code> value that is greater than or equal to the argument and is equal to a
                            mathematical integer. Essentially, it <b>rounds up</b>.
                        </li>
                        <li><code><b>Math.floor(double a)</b></code>: Returns the largest (closest to positive infinity)
                            <code>double</code> value that is less than or equal to the argument and is equal to a
                            mathematical integer. Essentially, it <b>rounds down</b>.
                        </li>
                        <li><code><b>Math.round(float a)</b></code> / <code><b>Math.round(double a)</b></code>: Returns
                            the closest `long` or `int` to the argument. It uses standard rounding rules: if the
                            fractional part is `.5` or greater, it rounds up; otherwise, it rounds down.</li>
                    </ul>
                    <pre><code>
// Example: Math.ceil() - rounds up
double ceil1 = Math.ceil(4.3);
System.out.println("ceil(4.3) = " + ceil1); // Output: ceil(4.3) = 5.0
double ceil2 = Math.ceil(4.0);
System.out.println("ceil(4.0) = " + ceil2); // Output: ceil(4.0) = 4.0
double ceil3 = Math.ceil(-4.7);
System.out.println("ceil(-4.7) = " + ceil3); // Output: ceil(-4.7) = -4.0 (rounds up towards zero)

// Example: Math.floor() - rounds down
double floor1 = Math.floor(4.7);
System.out.println("floor(4.7) = " + floor1); // Output: floor(4.7) = 4.0
double floor2 = Math.floor(4.0);
System.out.println("floor(4.0) = " + floor2); // Output: floor(4.0) = 4.0
double floor3 = Math.floor(-4.3);
System.out.println("floor(-4.3) = " + floor3); // Output: floor(-4.3) = -5.0 (rounds down away from zero)

// Example: Math.round() - standard rounding
long round1 = Math.round(4.6);
System.out.println("round(4.6) = " + round1); // Output: round(4.6) = 5
long round2 = Math.round(4.3);
System.out.println("round(4.3) = " + round2); // Output: round(4.3) = 4
long round3 = Math.round(4.5); // .5 rounds up
System.out.println("round(4.5) = " + round3); // Output: round(4.5) = 5
long round4 = Math.round(-4.5); // .5 away from zero
System.out.println("round(-4.5) = " + round4); // Output: round(-4.5) = -4 (note: behavior for .5 can vary in different languages, Java rounds up to nearest integer)
        </code></pre>
                </div>

                <h4>Other Useful Math Constants and Methods:</h4>

                <div class="concept-box">
                    <h4>Constants: `Math.PI` and `Math.E`</h4>
                    <p>The <code>Math</code> class also provides two commonly used mathematical constants:</p>
                    <ul>
                        <li><code><b>Math.PI</b></code>: Represents the ratio of the circumference of a circle to its
                            diameter, approximately 3.14159.</li>
                        <li><code><b>Math.E</b></code>: Represents the base of the natural logarithms, approximately
                            2.71828.</li>
                    </ul>
                    <pre><code>
System.out.println("Value of PI: " + Math.PI); // Output: Value of PI: 3.141592653589793
System.out.println("Value of E: " + Math.E);   // Output: Value of E: 2.718281828459045
        </code></pre>
                </div>

                <div class="concept-box">
                    <h4>Trigonometric Methods</h4>
                    <p>For working with angles and triangles, Java's `Math` class offers standard trigonometric
                        functions:</p>
                    <ul>
                        <li><code><b>Math.sin(double radians)</b></code>: Sine of an angle.</li>
                        <li><code><b>Math.cos(double radians)</b></code>: Cosine of an angle.</li>
                        <li><code><b>Math.tan(double radians)</b></code>: Tangent of an angle.</li>
                        <li><code><b>Math.toRadians(double degrees)</b></code>: Converts an angle measured in degrees to
                            an approximately equivalent angle measured in radians.</li>
                        <li><code><b>Math.toDegrees(double radians)</b></code>: Converts an angle measured in radians to
                            an approximately equivalent angle measured in degrees.</li>
                    </ul>
                    <pre><code>
// Calculate sine of 90 degrees
double angleDegrees = 90;
double angleRadians = Math.toRadians(angleDegrees);
double sineValue = Math.sin(angleRadians);
System.out.println("Sine of 90 degrees: " + sineValue); // Output: Sine of 90 degrees: 1.0 (approximately)

// Calculate cosine of 0 degrees
double cosValue = Math.cos(Math.toRadians(0));
System.out.println("Cosine of 0 degrees: " + cosValue); // Output: Cosine of 0 degrees: 1.0
        </code></pre>
                </div>

                <div class="concept-box">
                    <h4>Logarithmic and Exponential Methods</h4>
                    <p>For operations involving exponents and logarithms:</p>
                    <ul>
                        <li><code><b>Math.exp(double a)</b></code>: Returns Euler's number `e` raised to the power of
                            `a` ($e^a$).</li>
                        <li><code><b>Math.log(double a)</b></code>: Returns the natural logarithm (base `e`) of a
                            `double` value.</li>
                        <li><code><b>Math.log10(double a)</b></code>: Returns the base 10 logarithm of a `double` value.
                        </li>
                    </ul>
                    <pre><code>
System.out.println("e^1 = " + Math.exp(1));    // Output: e^1 = 2.718... (Value of E)
System.out.println("log(e) = " + Math.log(Math.E)); // Output: log(e) = 1.0
System.out.println("log10(100) = " + Math.log10(100)); // Output: log10(100) = 2.0
        </code></pre>
                </div>

                <p>By leveraging the rich set of methods available in the `Math` class, you can perform a wide range of
                    mathematical computations directly and efficiently in your Java applications.</p>

                <h3>8. Date & Time</h3>
                <p>Prior to Java 8, handling dates and times in Java was often cumbersome and prone to errors, primarily
                    due to the design flaws in the older <code>java.util.Date</code> and <code>java.util.Calendar</code>
                    classes. The introduction of the new Date and Time API (JSR 310) in Java 8, located in the
                    <code><b>java.time</b></code> package, revolutionized how developers interact with dates and times.
                    This modern API provides a more intuitive, immutable, and thread-safe approach to date and time
                    operations, making it much easier to write clear and robust code.
                </p>

                <div class="highlight">
                    <p><strong>Key Innovations and Advantages of the Java 8 Date-Time API (`java.time`):</strong></p>
                    <ul>
                        <li><b>Immutability:</b> All core date-time objects (like <code>LocalDate</code>,
                            <code>LocalTime</code>, <code>LocalDateTime</code>) are immutable. Operations like adding
                            days or setting a new year return a *new* object, ensuring thread safety and preventing
                            unintended side effects.
                        </li>
                        <li><b>Clarity & Domain-Driven Design:</b> Distinct classes are provided for different aspects
                            of time (e.g., date-only, time-only, date-time with/without timezone), making the code more
                            readable and less ambiguous.</li>
                        <li><b>Fluent API:</b> Methods are designed to be chainable, allowing for expressive and concise
                            operations (e.g., <code>today.plusYears(1).minusMonths(2)</code>).</li>
                        <li><b>Separation of Concerns:</b> Clear distinction between human date/time
                            (<code>LocalDate</code>, <code>LocalTime</code>), machine time (<code>Instant</code>), and
                            time-zone specific time (<code>ZonedDateTime</code>).</li>
                        <li><b>ISO-8601 Standard Compliant:</b> The API is based on the widely adopted ISO-8601 standard
                            for date and time representation, improving interoperability.</li>
                        <li><b>Improved Time Zone Handling:</b> Provides robust and explicit classes for dealing with
                            time zones (<code>ZoneId</code>, <code>ZonedDateTime</code>), addressing a major pain point
                            of older APIs.</li>
                    </ul>
                </div>

                <h4>Core Classes in the `java.time` package:</h4>
                <p>The `java.time` package includes several fundamental classes that represent different facets of date
                    and time information. Here are the most commonly used ones:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Class</th>
                            <th>Description</th>
                            <th>Example Representation</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr class="important-class-row">
                            <td><code><b>LocalDate</b></code></td>
                            <td>Represents a date (year, month, day) without time or time-zone information. Ideal for
                                birthdays, holidays, or specific dates where time of day isn't relevant.</td>
                            <td>(yyyy-MM-dd) e.g., <code>2024-12-25</code></td>
                        </tr>
                        <tr class="important-class-row">
                            <td><code><b>LocalTime</b></code></td>
                            <td>Represents a time (hour, minute, second and nanoseconds) without date or time-zone
                                information. Useful for opening hours, meeting times, etc.</td>
                            <td>(HH-mm-ss-ns) e.g., <code>14:30:00.123456789</code></td>
                        </tr>
                        <tr class="important-class-row">
                            <td><code><b>LocalDateTime</b></code></td>
                            <td>Represents both a date and a time (year, month, day, hour, minute, second, nanoseconds)
                                without time-zone. Suitable for events where both date and time are important but
                                location-specific time isn't a primary concern.</td>
                            <td>(yyyy-MM-dd-HH-mm-ss-ns) e.g., <code>2024-12-25T14:30:00</code></td>
                        </tr>
                        <tr>
                            <td><code><b>ZonedDateTime</b></code></td>
                            <td>Represents a complete date-time with a time-zone. Crucial for applications that need to
                                handle different geographical locations and daylight saving changes accurately.</td>
                            <td>e.g., <code>2024-12-25T14:30:00+05:30[Asia/Kolkata]</code></td>
                        </tr>
                        <tr>
                            <td><code><b>Instant</b></code></td>
                            <td>Represents a specific point in time on the timeline, often used for machine-readable
                                timestamps. It's counted from the epoch of 1970-01-01T00:00:00Z in nanoseconds.</td>
                            <td>e.g., <code>2025-05-30T06:08:55.123456789Z</code></td>
                        </tr>
                        <tr>
                            <td><code><b>Duration</b></code></td>
                            <td>Represents a quantity of time in terms of seconds and nanoseconds. Useful for measuring
                                periods between two <code>Instant</code>s or <code>LocalTime</code>s.</td>
                            <td>e.g., <code>PT8H6M12S</code> (8 hours, 6 minutes, 12 seconds)</td>
                        </tr>
                        <tr>
                            <td><code><b>Period</b></code></td>
                            <td>Represents a quantity of time in terms of years, months, and days. Useful for measuring
                                periods between two <code>LocalDate</code>s.</td>
                            <td>e.g., <code>P1Y2M3D</code> (1 year, 2 months, 3 days)</td>
                        </tr>
                        <tr class="important-class-row">
                            <td><code><b>DateTimeFormatter</b></code></td>
                            <td>A formatter for displaying and parsing date-time objects in various human-readable
                                string formats. Essential for converting date-time objects to strings and vice versa.
                            </td>
                            <td>Custom patterns like <code>"dd-MM-yyyy HH:mm:ss"</code></td>
                        </tr>
                    </tbody>
                </table>

                <pre><code>
// Java 8 Date-Time API - Basic Usage
import java.time.LocalDate;
import java.time.LocalTime;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter; // Don't forget to import this!
import java.time.Period; // For date calculations
import java.time.Duration; // For time calculations

// 1. Getting Current Date, Time, and Date-Time
LocalDate today = LocalDate.now();
System.out.println("Current Date: " + today); // Output: Current Date: 2025-05-30

LocalTime currentTime = LocalTime.now();
System.out.println("Current Time: " + currentTime); // Output: Current Time: 12:20:18.123456789 (based on current time)

LocalDateTime dateTime = LocalDateTime.now();
System.out.println("Current Date and Time: " + dateTime); // Output: Current Date and Time: 2025-05-30T12:20:18.123456789 (based on current time)

// 2. Creating Specific Dates, Times, and Date-Times
LocalDate specificDate = LocalDate.of(2024, 12, 25); // Year, Month (enum or int), Day
System.out.println("Specific Date: " + specificDate); // Output: Specific Date: 2024-12-25

LocalTime specificTime = LocalTime.of(14, 30, 0); // Hour, Minute, Second (optional: nanoseconds)
System.out.println("Specific Time: " + specificTime); // Output: Specific Time: 14:30

LocalDateTime specificDateTime = LocalDateTime.of(2023, 7, 15, 9, 0, 0);
System.out.println("Specific Date-Time: " + specificDateTime); // Output: Specific Date-Time: 2023-07-15T09:00

// 3. Formatting Date-Time Objects (Converting to String)
// DateTimeFormatter uses predefined constants or custom patterns.
DateTimeFormatter customFormatter = DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm:ss");
String formattedDateTime = dateTime.format(customFormatter);
System.out.println("Formatted Date and Time: " + formattedDateTime); // Example Output: 30-05-2025 12:20:18

DateTimeFormatter shortDateFormatter = DateTimeFormatter.ofPattern("MM/dd/yyyy");
String formattedDateShort = today.format(shortDateFormatter);
System.out.println("Formatted Date (Short): " + formattedDateShort); // Example Output: 05/30/2025

// 4. Parsing Strings to Date-Time Objects (Converting from String)
String dateString = "15-08-2024";
LocalDate parsedDate = LocalDate.parse(dateString, DateTimeFormatter.ofPattern("dd-MM-yyyy"));
System.out.println("Parsed Date: " + parsedDate); // Output: Parsed Date: 2024-08-15

String timeString = "22:15:00";
LocalTime parsedTime = LocalTime.parse(timeString); // Uses default ISO format (HH:mm:ss)
System.out.println("Parsed Time: " + parsedTime); // Output: Parsed Time: 22:15

// 5. Date and Time Calculations (Adding/Subtracting Units)
// These methods return new immutable objects with the modified values.
LocalDate nextWeek = today.plusWeeks(1);
System.out.println("Next Week: " + nextWeek); // Example Output: Next Week: 2025-06-06

LocalDate lastMonth = today.minusMonths(1);
System.out.println("Last Month: " + lastMonth); // Example Output: Last Month: 2025-04-30

LocalDateTime twoHoursLater = dateTime.plusHours(2);
System.out.println("Two Hours Later: " + twoHoursLater);

// Adding/Subtracting more specific units
LocalDate futureDate = today.plusYears(1).minusDays(5);
System.out.println("Future Date: " + futureDate);

// 6. Extracting Information
int year = today.getYear();
int month = today.getMonthValue(); // 1-12
int day = today.getDayOfMonth();
System.out.println("Year: " + year + ", Month: " + month + ", Day: " + day);

int hour = currentTime.getHour();
int minute = currentTime.getMinute();
System.out.println("Hour: " + hour + ", Minute: " + minute);

// 7. Comparing Dates and Times
LocalDate date1 = LocalDate.of(2025, 1, 1);
LocalDate date2 = LocalDate.of(2025, 1, 30);

System.out.println("date1 is before date2: " + date1.isBefore(date2)); // Output: true
System.out.println("date1 is after date2: " + date1.isAfter(date2));   // Output: false
System.out.println("date1 is equal to date2: " + date1.isEqual(date2)); // Output: false

// 8. Measuring Periods and Durations
// Period: for date-based amounts (years, months, days)
LocalDate startDate = LocalDate.of(2024, 1, 1);
LocalDate endDate = LocalDate.of(2025, 5, 30); // Using current date for example
Period period = Period.between(startDate, endDate);
System.out.println("Period between dates: " + period.getYears() + " years, " +
                   period.getMonths() + " months, " + period.getDays() + " days");
// Output for current date (May 30, 2025): Period between dates: 1 years, 4 months, 29 days

// Duration: for time-based amounts (hours, minutes, seconds, nanos)
LocalTime startTime = LocalTime.of(9, 0, 0);
LocalTime endTime = LocalTime.of(17, 30, 0);
Duration duration = Duration.between(startTime, endTime);
System.out.println("Duration between times (seconds): " + duration.getSeconds()); // Output: 30600 seconds (8.5 hours)
System.out.println("Duration between times (hours): " + duration.toHours());   // Output: 8 hours
    </code></pre>

                <p>By embracing the `java.time` package, Java developers can handle dates and times with greater
                    confidence, accuracy, and efficiency.</p>

                <h3>9. Exception Handling</h3>
                <p>Exception handling is a crucial mechanism in Java (and other programming languages) that allows you
                    to manage runtime errors gracefully, preventing your program from crashing unexpectedly. When an
                    error occurs during program execution that disrupts its normal flow, an "exception" is said to have
                    occurred.</p>

                <div class="highlight">
                    <p><strong>Why is Exception Handling Important?</strong></p>
                    <ul>
                        <li><b>Graceful Degradation:</b> Instead of abrupt termination, your program can respond to
                            errors in a controlled way (e.g., logging the error, informing the user, attempting
                            recovery).</li>
                        <li><b>Separation of Concerns:</b> It allows you to separate the normal logic of your code from
                            the error-handling logic, making the code cleaner and easier to maintain.</li>
                        <li><b>Robustness:</b> Makes applications more resilient to unforeseen issues like network
                            problems, invalid user input, or file system errors.</li>
                    </ul>
                </div>

                <h4>Exception Hierarchy</h4>
                <p>All exceptions and errors in Java are subclasses of the <code><b>java.lang.Throwable</b></code>
                    class. The hierarchy is broadly divided into two main branches:</p>
                <ul>
                    <li><code><b>Error</b></code>: Represents serious problems that applications should not try to
                        catch. These typically indicate external system problems (e.g., `OutOfMemoryError`,
                        `StackOverflowError`). You usually don't handle these.</li>
                    <li><code><b>Exception</b></code>: Represents conditions that an application might want to catch and
                        handle. Most problems you encounter will be `Exception`s.
                        <ul>
                            <li><code><b>RuntimeException</b></code> (Unchecked Exceptions): Subclasses of
                                `RuntimeException`. These typically indicate programming bugs (e.g.,
                                `NullPointerException` if you try to use something that is `null`, `ArithmeticException`
                                like dividing by zero, `ArrayIndexOutOfBoundsException` if you try to access an array
                                element that doesn't exist). The compiler does *not* force you to catch or declare them.
                            </li>
                            <li>Other `Exception` subclasses (Checked Exceptions): These are exceptions that the
                                compiler *forces* you to either catch using a `try-catch` block or declare using the
                                `throws` keyword in the method signature (e.g., `IOException` for file errors,
                                `SQLException` for database errors). The compiler "checks" if you've handled them.</li>
                        </ul>
                    </li>
                </ul>

                <h4>1. The `try-catch-finally` Block</h4>
                <p>The `try-catch-finally` block is the fundamental way to handle exceptions. It lets you "try" some
                    code, "catch" any specific errors that happen, and run "finally" a cleanup part no matter what.</p>
                <ul>
                    <li><code><b>try</b></code>: Put the code that *might* cause an error here.</li>
                    <li><code><b>catch</b></code>: If an error (exception) happens in the `try` block, Java jumps here.
                        You specify what type of error to catch.</li>
                    <li><code><b>finally</b></code>: This block runs *always*, whether an error happened or not. It's
                        useful for cleaning up, like closing files.</li>
                </ul>

                <pre><code>
// Example: Dividing by zero (causes an ArithmeticException)
public class TryCatchFinallyExample {
    public static void main(String[] args) {
        System.out.println("--- Start of Program ---");

        try {
            System.out.println("Trying to divide 10 by 0...");
            int result = 10 / 0; // This line will cause an error (ArithmeticException)
            System.out.println("Result is: " + result); // This line will NOT be reached
        } catch (ArithmeticException e) {
            // This 'catch' block runs because we caught an ArithmeticException
            System.out.println("Oops! You tried to divide by zero!");
            System.out.println("Error details: " + e.getMessage()); // Tells you what the error was
            // e.printStackTrace(); // Uncomment this line to see the full error history, useful for debugging
        } finally {
            // This 'finally' block ALWAYS runs, no matter if there was an error or not.
            System.out.println("Finished the division attempt.");
        }

        System.out.println("--- Program Continues ---");

        // Another example: No error occurs
        try {
            System.out.println("\nTrying to divide 20 by 4...");
            int result = 20 / 4;
            System.out.println("Result is: " + result);
        } catch (ArithmeticException e) {
            // This 'catch' block will NOT run because no ArithmeticException occurred
            System.out.println("This message won't appear.");
        } finally {
            // This 'finally' block still runs!
            System.out.println("Finished the second division attempt.");
        }

        System.out.println("--- End of Program ---");
    }
}
    </code></pre>
                <div class="output-box">
                    <b>Output:</b>
                    <pre>
--- Start of Program ---
Trying to divide 10 by 0...
Oops! You tried to divide by zero!
Error details: / by zero
Finished the division attempt.
--- Program Continues ---

Trying to divide 20 by 4...
Result is: 5
Finished the second division attempt.
--- End of Program ---</pre>
                </div>

                <h4>2. Multiple `catch` Blocks</h4>
                <p>Sometimes, different types of errors can happen in the same `try` block. You can use multiple `catch`
                    blocks to handle each specific error differently. **Important:** Always put the most specific error
                    `catch` blocks first, and the most general (like `Exception`) last.</p>

                <pre><code>
// Example: Handling different types of common errors
public class MultipleCatchExample {
    public static void main(String[] args) {
        System.out.println("--- Handling Multiple Error Types ---");

        // --- Scenario 1: ArrayIndexOutOfBoundsException ---
        try {
            System.out.println("\nAttempting to access an invalid array index...");
            int[] numbers = {1, 2, 3};
            System.out.println("Accessing array element at index 5: " + numbers[5]);
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("Error! You tried to access a number outside the array's size.");
            System.out.println("Problem: " + e.getMessage());
        } catch (ArithmeticException e) {
            System.out.println("This won't be caught for array error.");
        } catch (Exception e) {
            System.out.println("An unexpected general error happened.");
        } finally {
            System.out.println("End of array access attempt.");
        }

        // --- Scenario 2: ArithmeticException ---
        try {
            System.out.println("\nAttempting division by zero...");
            int result = 10 / 0;
            System.out.println("Result: " + result);
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("This won't be caught for division by zero.");
        } catch (ArithmeticException e) {
            System.out.println("Error! You tried to divide by zero.");
            System.out.println("Problem: " + e.getMessage());
        } catch (Exception e) {
            System.out.println("An unexpected general error happened.");
        } finally {
            System.out.println("End of division attempt.");
        }

        // --- Scenario 3: NumberFormatException (if you uncomment the line inside try) ---
        try {
            System.out.println("\nAttempting to convert an invalid string to a number...");
            String invalidNum = "abc";
            int parsedNum = Integer.parseInt(invalidNum); // This causes NumberFormatException
            System.out.println("Parsed number: " + parsedNum);
        } catch (NumberFormatException e) {
            System.out.println("Error! Couldn't convert text to a whole number.");
            System.out.println("Problem: " + e.getMessage());
        } catch (Exception e) {
            System.out.println("An unexpected general error happened.");
        } finally {
            System.out.println("End of string conversion attempt.");
        }

        System.out.println("\n--- Program finished ---");
    }
}
    </code></pre>
                <div class="output-box">
                    <b>Output:</b>
                    <pre>
--- Handling Multiple Error Types ---

Attempting to access an invalid array index...
Error! You tried to access a number outside the array's size.
Problem: Index 5 out of bounds for length 3
End of array access attempt.

Attempting division by zero...
Error! You tried to divide by zero.
Problem: / by zero
End of division attempt.

Attempting to convert an invalid string to a number...
Error! Couldn't convert text to a whole number.
Problem: For input string: "abc"
End of string conversion attempt.

--- Program finished ---</pre>
                </div>

                <h4>3. `throw` Keyword (To Create and Send an Exception)</h4>
                <p>The `<b>throw</b>` statement allows you to create a custom error or send an existing error type. It's
                    used when *your code* detects a problem and needs to immediately stop the normal flow and signal an
                    error.</p>
                <p>The `throw` statement is used together with an **exception type**. There are many exception types
                    available in Java, both built-in ones like `ArithmeticException`, `FileNotFoundException`,
                    `ArrayIndexOutOfBoundsException`, `NullPointerException`, `SecurityException`, and custom ones you
                    create.</p>

                <pre><code>
// Example: Throwing an exception for invalid input
public class ThrowKeywordExample {

    // This method checks if a person's age is valid.
    public static void checkAge(int age) {
        if (age < 0) {
            // If age is less than 0, it's invalid.
            // We 'throw' a new IllegalArgumentException.
            // IllegalArgumentException is a built-in 'unchecked' exception (subclass of RuntimeException).
            // This means the caller doesn't *have* to catch it, but it's good practice.
            throw new IllegalArgumentException("Age cannot be a negative number: " + age);
        } else if (age > 120) {
            // If age is too high, also invalid.
            throw new IllegalArgumentException("Age is unbelievably high: " + age);
        } else {
            System.out.println("Age " + age + " is valid.");
        }
    }

    public static void main(String[] args) {
        System.out.println("--- Checking Ages ---");
        try {
            checkAge(30);  // This is valid
            checkAge(-10); // This will cause an IllegalArgumentException to be thrown
            checkAge(150); // This line will NOT be reached because of the exception above
        } catch (IllegalArgumentException e) {
            // We catch the IllegalArgumentException thrown by checkAge()
            System.out.println("Validation Error: " + e.getMessage());
            // e.printStackTrace(); // Uncomment to see the full error history
        }
        System.out.println("--- Finished Checking Ages ---");
    }
}
    </code></pre>
                <div class="output-box">
                    <b>Output:</b>
                    <pre>
--- Checking Ages ---
Age 30 is valid.
Validation Error: Age cannot be a negative number: -10
--- Finished Checking Ages ---</pre>
                </div>

                <h4>4. `throws` Keyword (To Declare a Method Might Send an Exception)</h4>
                <p>The `<b>throws</b>` keyword is used in a method's signature (its declaration) to tell anyone who uses
                    that method: "Hey, I might throw a **checked exception**, so you need to be ready to handle it or
                    declare it yourself." The compiler will *force* you to deal with checked exceptions.</p>

                <pre><code>
import java.io.FileNotFoundException; // A common CHECKED exception

public class ThrowsKeywordExample {

    // This method says: "I might throw a FileNotFoundException."
    // You don't HAVE to catch it here, but whoever calls this method MUST.
    public static void openFile(String filename) throws FileNotFoundException {
        System.out.println("Attempting to open file: " + filename);
        // In a real program, this would try to open a file.
        // For demonstration, we'll simulate an error if the file is "nonexistent.txt"
        if (filename.equals("nonexistent.txt")) {
            // We 'throw' a new FileNotFoundException.
            // Since FileNotFoundException is a CHECKED exception,
            // we MUST declare it in the method signature using 'throws'.
            throw new FileNotFoundException("Error: File '" + filename + "' was not found!");
        }
        System.out.println("File opened successfully (simulated).");
    }

    public static void main(String[] args) {
        System.out.println("--- File Operations ---");

        // Scenario 1: File that exists (simulated)
        try {
            openFile("my_document.txt"); // No exception thrown here
        } catch (FileNotFoundException e) {
            System.out.println("Caught an error for my_document.txt: " + e.getMessage());
        }

        System.out.println("--------------------");

        // Scenario 2: File that does NOT exist (simulated)
        try {
            openFile("nonexistent.txt"); // This will cause a FileNotFoundException to be thrown
        } catch (FileNotFoundException e) {
            // We MUST catch this exception because openFile() declared it with 'throws'.
            System.out.println("Caught an error for nonexistent.txt: " + e.getMessage());
        }
        System.out.println("--- File Operations Complete ---");
    }
}
    </code></pre>
                <div class="output-box">
                    <b>Output:</b>
                    <pre>
--- File Operations ---
Attempting to open file: my_document.txt
File opened successfully (simulated).
--------------------
Attempting to open file: nonexistent.txt
Caught an error for nonexistent.txt: Error: File 'nonexistent.txt' was not found!
--- File Operations Complete ---</pre>
                </div>

                <h4>5. Difference Between `throw` and `throws`</h4>
                <p>While `throw` and `throws` sound similar, they serve very different purposes in Java exception
                    handling. Think of them as two distinct tools in your error management toolkit:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>`throw` Keyword</th>
                            <th>`throws` Keyword</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><b>Purpose</b></td>
                            <td>Used to **explicitly raise (throw)** an exception. It's like saying, "An error just
                                happened here!"</td>
                            <td>Used in a method signature to **declare** that a method *might* throw one or more
                                checked exceptions. It's like saying, "Warning: this method *could* cause an error of
                                this type!"</td>
                        </tr>
                        <tr>
                            <td><b>Usage</b></td>
                            <td>Followed by an **instance (object)** of an exception.
                                <br>Example: `throw new ArithmeticException("Cannot divide by zero");`
                            </td>
                            <td>Followed by one or more **exception class names**.
                                <br>Example: `public void readFile() throws IOException, InterruptedException`
                            </td>
                        </tr>
                        <tr>
                            <td><b>Placement</b></td>
                            <td>Used **inside** a method body, typically within an `if` condition or logic block.</td>
                            <td>Used in the **method signature** (after the method parameters and before the curly
                                brace).</td>
                        </tr>
                        <tr>
                            <td><b>Quantity</b></td>
                            <td>You can only `throw` **one** exception object at a time.</td>
                            <td>You can `throws` **multiple** exception classes, separated by commas.</td>
                        </tr>
                        <tr>
                            <td><b>Flow</b></td>
                            <td>Immediately stops the normal execution flow and transfers control to the nearest `catch`
                                block.</td>
                            <td>Does not stop the flow of execution; it's a declaration for the compiler and other
                                developers.</td>
                        </tr>
                        <tr>
                            <td><b>Context</b></td>
                            <td>Performs the **actual throwing** of an exception.</td>
                            <td>Performs the **declaration** of potential exceptions, shifting the responsibility of
                                handling to the caller.</td>
                        </tr>
                    </tbody>
                </table>

                <p>In short: You **`throw`** an exception to *make* it happen, and a method **`throws`** an exception to
                    *warn* that it *might* happen (especially for checked exceptions).</p>

                <h4>6. Custom Exceptions</h4>
                <p>Sometimes, Java's built-in exceptions aren't specific enough for the errors in your program. You can
                    create your own custom exception classes to make your error messages clearer and more meaningful.
                    This makes your code easier to understand and debug.</p>

                <div class="concept-box">
                    <h4>How to create a Custom Exception:</h4>
                    <p>1. Create a new class.</p>
                    <p>2. It should <code><b>extend Exception</b></code> (for a **checked exception**, meaning users
                        *must* handle it) OR <code><b>extend RuntimeException</b></code> (for an **unchecked
                        exception**, meaning users *don't have to* handle it, often for logic errors).</p>
                    <p>3. Add constructors, typically one that takes a `String message` (which you pass to the parent
                        class using `super(message)`).</p>
                </div>
                <pre><code>
// 1. Define a Custom Checked Exception (forces handling)
class TooYoungException extends Exception {
    public TooYoungException(String message) {
        super(message); // Pass the message to the parent Exception class
    }
}

// 2. Define a Custom Unchecked Exception (handling is optional)
class InsufficientFundsException extends RuntimeException {
    public InsufficientFundsException(String message) {
        super(message); // Pass the message to the parent RuntimeException class
    }
}

public class CustomExceptionDemo {

    // Method that throws our Custom CHECKED Exception
    // We use 'throws' because TooYoungException is a CHECKED exception.
    public static void applyForLicense(int age) throws TooYoungException {
        if (age < 18) {
            // We 'throw' our custom TooYoungException here
            throw new TooYoungException("Sorry, you are too young to apply for a license. Age: " + age);
        }
        System.out.println("License application accepted for age: " + age);
    }

    // Method that throws our Custom UNCHECKED Exception
    // We don't use 'throws' here because InsufficientFundsException is UNCHECKED.
    public static void makeWithdrawal(double amount, double currentBalance) {
        if (amount > currentBalance) {
            // We 'throw' our custom InsufficientFundsException here
            throw new InsufficientFundsException(
                "Cannot withdraw " + amount + ". Current balance is only " + currentBalance
            );
        }
        System.out.println("Withdrawal of " + amount + " successful. New balance: " + (currentBalance - amount));
    }

    public static void main(String[] args) {
        System.out.println("--- License Application ---");
        // Handling the Custom CHECKED Exception (TooYoungException)
        try {
            applyForLicense(20); // This will work
            applyForLicense(16); // This will throw TooYoungException, caught below
        } catch (TooYoungException e) {
            System.out.println("License Error: " + e.getMessage());
        }

        System.out.println("\n--- Bank Withdrawal ---");
        // Handling the Custom UNCHECKED Exception (InsufficientFundsException)
        // Catching is optional, but good practice if you want to display a user-friendly message.
        try {
            makeWithdrawal(50, 200); // This will work
            makeWithdrawal(300, 150); // This will throw InsufficientFundsException, caught below
        } catch (InsufficientFundsException e) {
            System.out.println("Bank Error: " + e.getMessage());
        }

        System.out.println("\n--- Program finished ---");
    }
}
    </code></pre>
                <div class="output-box">
                    <b>Output:</b>
                    <pre>
--- License Application ---
License application accepted for age: 20
License Error: Sorry, you are too young to apply for a license. Age: 16

--- Bank Withdrawal ---
Withdrawal of 50.0 successful. New balance: 150.0
Bank Error: Cannot withdraw 300.0. Current balance is only 150.0

--- Program finished ---</pre>
                </div>

                <h4>7. `try-with-resources` (Java 7+)</h4>
                <p>When you work with resources like files, network connections, or database connections, it's very
                    important to *close* them when you're done. If you don't, your program can leak resources and cause
                    problems. Before Java 7, you often used a `finally` block to ensure closing. But
                    `<b>try-with-resources</b>` makes it much easier and safer!</p>
                <p>If a resource implements the `<b>AutoCloseable</b>` interface (like `FileWriter` or `Scanner`), you
                    can declare it inside the `try` block's parentheses. Java will automatically close that resource for
                    you when the `try` block finishes, whether an exception occurs or not.</p>

                <pre><code>
import java.io.FileWriter;
import java.io.IOException;
import java.util.Scanner; // For reading keyboard input or files
import java.io.File; // To create a File object
import java.nio.file.Files; // Used for simple file creation/deletion
import java.nio.file.Paths; // Used for simple file creation/deletion

public class TryWithResourcesSimpleExample {
    public static void main(String[] args) {
        System.out.println("--- File Writing Example ---");

        // First, let's make sure the file exists before reading later
        // This part isn't strictly try-with-resources related, just setup
        try {
            Files.write(Paths.get("greeting.txt"), "This is line one.\nThis is line two.".getBytes());
            System.out.println("Created 'greeting.txt' with initial content.");
        } catch (IOException e) {
            System.err.println("Setup error: Could not create greeting.txt: " + e.getMessage());
            return; // Stop if we can't even create the file
        }


        // Using try-with-resources for a FileWriter
        // The 'writer' will be automatically closed when this block finishes,
        // even if an error happens inside.
        try (FileWriter writer = new FileWriter("greeting.txt")) {
            System.out.println("\nAttempting to write over greeting.txt...");
            writer.write("Hello from Java!");
            writer.write("\nThis line is also written by the FileWriter.");
            System.out.println("Text written to greeting.txt successfully.");
            // No need for writer.close() here! Java handles it automatically.
        } catch (IOException e) {
            System.out.println("Error writing to file: " + e.getMessage());
            e.printStackTrace();
        }

        System.out.println("\n--- File Reading Example ---");

        // Using try-with-resources for a Scanner to read the file we just wrote
        try (Scanner fileReader = new Scanner(new File("greeting.txt"))) {
            System.out.println("Content of greeting.txt:");
            while (fileReader.hasNextLine()) {
                String line = fileReader.nextLine();
                System.out.println(line);
            }
        } catch (IOException e) { // Catch IOException for file operations (like file not found)
            System.out.println("Error reading file: " + e.getMessage());
            e.printStackTrace();
        } finally {
            // 'finally' still runs, but it's not needed for closing resources declared in try-with-resources.
            // You can use it for other actions that must happen at the end.
            System.out.println("File operation attempt complete (from finally block).");
        }

        // Clean up the dummy file
        try {
            Files.deleteIfExists(Paths.get("greeting.txt"));
            System.out.println("Cleaned up greeting.txt.");
        } catch (IOException e) {
            System.err.println("Could not delete greeting.txt: " + e.getMessage());
        }
        System.out.println("\n--- Program finished ---");
    }
}
    </code></pre>
                <div class="output-box">
                    <b>Output:</b>
                    <pre>
--- File Writing Example ---
Created 'greeting.txt' with initial content.

Attempting to write over greeting.txt...
Text written to greeting.txt successfully.

--- File Reading Example ---
Content of greeting.txt:
Hello from Java!
This line is also written by the FileWriter.
File operation attempt complete (from finally block).
Cleaned up greeting.txt.

--- Program finished ---</pre>
                </div>

                <h3>10. File Operations</h3>
                <p>File operations are fundamental in many applications, allowing programs to store, retrieve, and
                    manage persistent data. Java provides robust input/output (I/O) capabilities through its
                    <code>java.io</code> package and, more recently, enhanced capabilities with the
                    <code>java.nio.file</code> (NIO.2) package introduced in Java 7.
                </p>

                <div class="highlight">
                    <p><strong>Key Considerations for File Operations:</strong></p>
                    <ul>
                        <li><b>Exceptions:</b> File operations are inherently risky (e.g., file not found, permission
                            denied). You must always handle <code>IOException</code> (or its subclasses like
                            <code>FileNotFoundException</code>).
                        </li>
                        <li><b>Resource Management:</b> Streams and readers/writers consume system resources. It's
                            crucial to close them after use to prevent resource leaks. Java's <b>try-with-resources</b>
                            statement (introduced in Java 7) is the recommended way to ensure resources are closed
                            automatically.</li>
                        <li><b>Text vs. Binary:</b> Choose appropriate streams/readers for text data (character streams
                            like <code>Reader</code>/<code>Writer</code>) versus binary data (byte streams like
                            <code>InputStream</code>/<code>OutputStream</code>).
                        </li>
                    </ul>
                </div>

                <h4>The `java.io.File` Class</h4>
                <p>The <code>java.io.File</code> class is a core component for interacting with the file system. It
                    represents file and directory pathnames. It doesn't actually store the data within the file but
                    provides methods to manipulate the file itself (e.g., check if it exists, create, delete, rename,
                    list contents of a directory).</p>

                <pre><code>
import java.io.File; // Import the File class
import java.io.IOException; // Handle IO exceptions

public class FileBasics {
    public static void main(String[] args) {
        File myFile = new File("myfile.txt"); // Create a File object, not the actual file yet

        // Check if the file exists
        if (myFile.exists()) {
            System.out.println("File name: " + myFile.getName());
            System.out.println("Absolute path: " + myFile.getAbsolutePath());
            System.out.println("Writable: " + myFile.canWrite());
            System.out.println("Readable: " + myFile.canRead());
            System.out.println("File size in bytes: " + myFile.length());
        } else {
            System.out.println("File does not exist.");
        }
    }
}
    </code></pre>

                <h4>1. Creating Files</h4>
                <p>To create a new, empty file, you use the <code>createNewFile()</code> method of the <code>File</code>
                    object. This method returns <code>true</code> if the file was successfully created and
                    <code>false</code> if the file already existed.
                </p>
                <div class="concept-box">
                    <h4>Method: `fileObject.createNewFile()`</h4>
                    <ul>
                        <li>Returns <code>true</code> if the named file does not exist and was successfully created.
                        </li>
                        <li>Returns <code>false</code> if the named file already exists.</li>
                        <li>Throws <code>IOException</code> if an I/O error occurred (e.g., permission issues, path not
                            valid).</li>
                    </ul>
                </div>
                <pre><code>
import java.io.File;
import java.io.IOException;

public class CreateFileExample {
    public static void main(String[] args) {
        File file = new File("newfile.txt");
        try {
            if (file.createNewFile()) {
                System.out.println("File created: " + file.getName());
            } else {
                System.out.println("File already exists.");
            }
        } catch (IOException e) {
            System.out.println("An error occurred during file creation.");
            e.printStackTrace(); // Print the stack trace for debugging
        }
    }
}
    </code></pre>

                <h4>2. Writing to Files</h4>
                <p>Java provides several classes for writing data to files. For writing character data (text),
                    <code>FileWriter</code> and <code>BufferedWriter</code> are commonly used. For raw byte data,
                    `FileOutputStream` is used.
                </p>

                <div class="concept-box">
                    <h4>Using `FileWriter` (for basic text writing)</h4>
                    <p>The <code>FileWriter</code> class is used to write character-oriented data to a file. You can
                        specify whether to overwrite the file or append to it.</p>
                    <ul>
                        <li><b>Constructor:</b> <code>new FileWriter("filename.txt")</code> (overwrites if file exists)
                        </li>
                        <li><b>Constructor:</b> <code>new FileWriter("filename.txt", true)</code> (appends if file
                            exists)</li>
                        <li><b>Method:</b> <code>writer.write(String text)</code>: Writes a string.</li>
                        <li><b>Method:</b> <code>writer.close()</code>: **Crucial** to flush and close the stream.</li>
                    </ul>
                </div>
                <pre><code>
import java.io.FileWriter;
import java.io.IOException;

public class WriteFileExample {
    public static void main(String[] args) {
        // Writing to a file (overwrites existing content)
        try (FileWriter writer = new FileWriter("output.txt")) { // try-with-resources for auto-closing
            writer.write("Hello, Java I/O!\n");
            writer.write("This is a new line.\n");
            System.out.println("Successfully wrote to 'output.txt'.");
        } catch (IOException e) {
            System.out.println("Error writing to file: " + e.getMessage());
            e.printStackTrace();
        }

        // Appending to a file (adds content to the end)
        try (FileWriter writer = new FileWriter("output.txt", true)) { // 'true' for append mode
            writer.write("Appending this line.\n");
            writer.write("And another one.\n");
            System.out.println("Successfully appended to 'output.txt'.");
        } catch (IOException e) {
            System.out.println("Error appending to file: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
    </code></pre>

                <div class="concept-box">
                    <h4>Using `BufferedWriter` (for efficient text writing)</h4>
                    <p>For better performance when writing large amounts of text data, it's recommended to wrap a
                        <code>FileWriter</code> (or any other <code>Writer</code>) in a <code>BufferedWriter</code>. It
                        uses an internal buffer to reduce actual writes to the disk.
                    </p>
                    <ul>
                        <li><b>Constructor:</b> <code>new BufferedWriter(new FileWriter("filename.txt"))</code></li>
                        <li><b>Method:</b> <code>writer.newLine()</code>: Writes a platform-specific new line.</li>
                        <li>Remember to <code>flush()</code> or <code>close()</code> to ensure buffered data is written.
                        </li>
                    </ul>
                </div>
                <pre><code>
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

public class BufferedWriteExample {
    public static void main(String[] args) {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter("buffered_output.txt"))) {
            writer.write("Line 1 from BufferedWriter.");
            writer.newLine(); // Writes platform-specific new line
            writer.write("Line 2 from BufferedWriter.");
            writer.newLine();
            System.out.println("Successfully wrote to 'buffered_output.txt' using BufferedWriter.");
        } catch (IOException e) {
            System.out.println("Error writing with BufferedWriter: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
    </code></pre>

                <h4>3. Reading Files</h4>
                <p>To read data from files, Java provides classes like <code>Scanner</code> and
                    <code>BufferedReader</code> for text, and <code>FileInputStream</code> for binary data.
                </p>

                <div class="concept-box">
                    <h4>Using `Scanner` (for reading text line by line or token by token)</h4>
                    <p>The <code>Scanner</code> class (from <code>java.util</code>) is versatile for parsing primitive
                        types and strings from input, including files. It's good for simple text file reading.</p>
                    <ul>
                        <li><b>Constructor:</b> <code>new Scanner(new File("filename.txt"))</code></li>
                        <li><b>Method:</b> <code>scanner.hasNextLine()</code>: Checks if there's another line.</li>
                        <li><b>Method:</b> <code>scanner.nextLine()</code>: Reads the next line.</li>
                        <li><b>Method:</b> <code>scanner.close()</code>: **Crucial** to close the scanner.</li>
                    </ul>
                </div>
                <pre><code>
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class ReadFileExample {
    public static void main(String[] args) {
        // Ensure output.txt exists from previous example or create it manually with some content
        try (Scanner fileReader = new Scanner(new File("output.txt"))) { // try-with-resources
            System.out.println("Reading 'output.txt':");
            while (fileReader.hasNextLine()) {
                String line = fileReader.nextLine();
                System.out.println(line);
            }
        } catch (FileNotFoundException e) {
            System.out.println("File not found: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
    </code></pre>

                <div class="concept-box">
                    <h4>Using `BufferedReader` (for efficient text reading)</h4>
                    <p>Similar to <code>BufferedWriter</code>, <code>BufferedReader</code> enhances performance when
                        reading character streams by buffering input. It's often preferred for reading large text files.
                    </p>
                    <ul>
                        <li><b>Constructor:</b> <code>new BufferedReader(new FileReader("filename.txt"))</code></li>
                        <li><b>Method:</b> <code>reader.readLine()</code>: Reads a line of text. Returns
                            <code>null</code> if end of stream is reached.
                        </li>
                    </ul>
                </div>
                <pre><code>
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class BufferedReadExample {
    public static void main(String[] args) {
        try (BufferedReader reader = new BufferedReader(new FileReader("buffered_output.txt"))) {
            System.out.println("Reading 'buffered_output.txt' using BufferedReader:");
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            System.out.println("Error reading with BufferedReader: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
    </code></pre>

                <h4>4. Deleting Files</h4>
                <p>To delete a file or an empty directory, you use the <code>delete()</code> method of the
                    <code>File</code> object. This method returns <code>true</code> if the deletion was successful and
                    <code>false</code> otherwise (e.g., file not found, permission denied, directory not empty).
                </p>
                <div class="concept-box">
                    <h4>Method: `fileObject.delete()`</h4>
                    <ul>
                        <li>Returns <code>true</code> if the file or directory was successfully deleted.</li>
                        <li>Returns <code>false</code> if the file or directory could not be deleted for any reason.
                        </li>
                        <li>Note: This method does not throw an <code>IOException</code> on failure; it simply returns
                            <code>false</code>.
                        </li>
                    </ul>
                </div>
                <pre><code>
import java.io.File;

public class DeleteFileExample {
    public static void main(String[] args) {
        // Create a dummy file to be deleted
        File fileToDelete = new File("file_to_delete.txt");
        try {
            fileToDelete.createNewFile(); // Ensure it exists for deletion attempt
            System.out.println("Created 'file_to_delete.txt' for demonstration.");
        } catch (IOException e) {
            System.out.println("Could not create dummy file: " + e.getMessage());
        }

        // Attempt to delete the file
        if (fileToDelete.delete()) {
            System.out.println("File deleted successfully: " + fileToDelete.getName());
        } else {
            System.out.println("Failed to delete the file: " + fileToDelete.getName() +
                               ". It might not exist, or permissions are insufficient, or it's in use.");
        }

        // Example of deleting a non-existent file
        File nonExistentFile = new File("non_existent_file.txt");
        if (nonExistentFile.delete()) {
            System.out.println("This should not happen: " + nonExistentFile.getName() + " was deleted.");
        } else {
            System.out.println("Correctly failed to delete non-existent file: " + nonExistentFile.getName());
        }
    }
}
    </code></pre>

                <h4>Modern File I/O with NIO.2 (Java 7+)</h4>
                <p>Introduced in Java 7, the NIO.2 API (<code>java.nio.file</code> package) provides a more powerful,
                    flexible, and robust way to handle file system operations. It addresses many limitations of the
                    older <code>java.io.File</code> class. Key components include:</p>
                <ul>
                    <li><code><b>Path</b></code> interface: Represents a path to a file or directory.</li>
                    <li><code><b>Paths</b></code> class: Utility class to get <code>Path</code> instances.</li>
                    <li><code><b>Files</b></code> class: Provides static methods for common file operations (copy, move,
                        delete, read all lines, write all bytes, etc.) that are often more efficient and handle
                        exceptions more uniformly.</li>
                </ul>

                <div class="highlight">
                    <p><strong>Why use NIO.2 (`java.nio.file`)?</strong></p>
                    <ul>
                        <li><b>Improved Error Handling:</b> Methods generally throw more specific exceptions (e.g.,
                            `NoSuchFileException`).</li>
                        <li><b>Atomic Operations:</b> Operations like `move` can be done atomically.</li>
                        <li><b>Symbolic Links:</b> Better support for symbolic links.</li>
                        <li><b>Stream API Integration:</b> `Files.lines()` allows reading files directly into a Java 8
                            Stream, making processing very concise.</li>
                        <li><b>Less Boilerplate:</b> Many common operations can be done with a single static method
                            call.</li>
                    </ul>
                </div>
                <pre><code>
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.List;

public class NIO2FileOperations {
    public static void main(String[] args) {
        Path filePath = Paths.get("nio2_example.txt");

        // 1. Create a file
        try {
            if (Files.notExists(filePath)) {
                Files.createFile(filePath);
                System.out.println("NIO.2: File created: " + filePath.getFileName());
            } else {
                System.out.println("NIO.2: File already exists.");
            }
        } catch (IOException e) {
            System.out.println("NIO.2: Error creating file: " + e.getMessage());
            e.printStackTrace();
        }

        // 2. Write to a file (overwrites)
        String content = "Hello from NIO.2!\nAnother line from Files.write.";
        try {
            Files.write(filePath, content.getBytes()); // Writes bytes
            System.out.println("NIO.2: Successfully wrote to file.");
        } catch (IOException e) {
            System.out.println("NIO.2: Error writing to file: " + e.getMessage());
            e.printStackTrace();
        }

        // 3. Append to a file
        String appendContent = "\nThis content was appended.";
        try {
            Files.write(filePath, appendContent.getBytes(), StandardOpenOption.APPEND);
            System.out.println("NIO.2: Successfully appended to file.");
        } catch (IOException e) {
            System.out.println("NIO.2: Error appending to file: " + e.getMessage());
            e.printStackTrace();
        }

        // 4. Read all lines from a file
        try {
            List<String> lines = Files.readAllLines(filePath); // Reads all lines into a List
            System.out.println("\nNIO.2: Content of file:");
            for (String line : lines) {
                System.out.println(line);
            }
        } catch (IOException e) {
            System.out.println("NIO.2: Error reading file: " + e.getMessage());
            e.printStackTrace();
        }

        // 5. Delete a file
        try {
            if (Files.exists(filePath)) {
                Files.delete(filePath);
                System.out.println("NIO.2: File deleted: " + filePath.getFileName());
            } else {
                System.out.println("NIO.2: File does not exist for deletion.");
            }
        } catch (IOException e) {
            System.out.println("NIO.2: Error deleting file: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
    </code></pre>

                <p>While the older <code>java.io</code> classes are still valid and widely used, for new development or
                    when dealing with complex file system interactions, the <code>java.nio.file</code> package (NIO.2)
                    is generally the preferred approach due to its modern design, robustness, and better error handling.
                </p>

                <h3>11. User Input</h3>
                <p>Many programs need to interact with the user, taking data or commands to perform their tasks. In
                    Java, the most common and beginner-friendly way to get input from the keyboard (the standard input
                    device) is by using the <code><b>Scanner</b></code> class.</p>

                <div class="highlight">
                    <p><b>What is `System.in`?</b><br>
                        <code>System.in</code> is a standard input stream in Java, typically representing the keyboard.
                        When you create a `Scanner` object with `System.in`, you're telling it to read from the
                        keyboard.
                    </p>
                </div>

                <h4>The `Scanner` Class (<code>java.util.Scanner</code>)</h4>
                <p>The `Scanner` class is part of the `java.util` package, so you'll usually need to `import
                    java.util.Scanner;` at the top of your Java file. It breaks down input into tokens (like words or
                    numbers) using a delimiter (by default, whitespace). It then provides various methods to read these
                    tokens as different data types.</p>

                <div class="concept-box">
                    <h4>How to use `Scanner`:</h4>
                    <ol>
                        <li><b>Import:</b> Add <code>import java.util.Scanner;</code> at the beginning of your file.
                        </li>
                        <li><b>Create Object:</b> Create a `Scanner` object, typically linking it to `System.in` for
                            keyboard input: <br> <code>Scanner scanner = new Scanner(System.in);</code></li>
                        <li><b>Read Input:</b> Use various `nextXxx()` methods to read different data types.</li>
                        <li><b>Close Scanner:</b> Always close the `Scanner` when you're done with it to release system
                            resources: <br> <code>scanner.close();</code> (though for `System.in`, there's a nuance, as
                            explained below).</li>
                    </ol>
                </div>

                <h4>Reading User Input</h4>
                <p>The `Scanner` class provides convenient methods to read input as specific data types. These methods
                    are essential for capturing various forms of user data from the keyboard. For a comprehensive list
                    of input reading methods, refer to the "More Useful `Scanner` Methods" table below.</p>

                <div class="highlight">
                    <p><b>Note:</b> If you enter wrong input (e.g., text like "hello" when expecting a number for
                        `nextInt()`), your program will throw an `<b>InputMismatchException</b>`. This is a common error
                        that needs to be handled using `try-catch` blocks for robust applications.</p>
                </div>

                <pre><code>
import java.util.Scanner; // Don't forget to import Scanner!

public class UserInputExample {
    public static void main(String[] args) {
        // 1. Create a Scanner object to read input from the keyboard (System.in)
        Scanner scanner = new Scanner(System.in);

        System.out.println("--- Gathering User Information ---");

        // 2. Reading different data types using Scanner methods

        // Reading a String (full line)
        System.out.print("Enter your name: ");
        String name = scanner.nextLine(); // Reads the whole line until Enter is pressed

        // Reading an integer
        System.out.print("Enter your age: ");
        int age = scanner.nextInt(); // Reads only the integer part

        // Reading a double (decimal number)
        System.out.print("Enter your salary: ");
        double salary = scanner.nextDouble(); // Reads only the double part

        // Reading a boolean (true/false)
        System.out.print("Are you employed? (true/false): ");
        boolean employed = scanner.nextBoolean(); // Reads "true" or "false"

        // Displaying the collected information
        System.out.println("\n--- Your Information ---");
        System.out.println("Name: " + name);
        System.out.println("Age: " + age);
        System.out.println("Salary: $" + salary);
        System.out.println("Employed: " + employed);

        // 3. Close the Scanner
        // For System.in, closing it can also close the underlying input stream
        // which might affect other parts of your program. For simple programs,
        // it's generally okay. For file Scanners, ALWAYS close.
        scanner.close();

        System.out.println("--- Program Finished ---");
    }
}
    </code></pre>
                <div class="output-box">
                    <b>Example Interaction (User Input is Bold):</b>
                    <pre>
--- Gathering User Information ---
Enter your name: <b>Alice Wonderland</b>
Enter your age: <b>30</b>
Enter your salary: <b>55000.75</b>
Are you employed? (true/false): <b>true</b>

--- Your Information ---
Name: Alice Wonderland
Age: 30
Salary: $55000.75
Employed: true
--- Program Finished ---</pre>
                </div>

                <h4>The `nextLine()` Trap (Important for Beginners!)</h4>
                <p>This is a very common issue for beginners mixing `nextInt()`, `nextDouble()`, `next()` with
                    `nextLine()`. When you use methods like `nextInt()`, `nextDouble()`, or `nextBoolean()`, they read
                    only the number/boolean you type, but they **do not consume the "newline" character** (the invisible
                    character generated when you press Enter). This newline character is left behind in the input
                    buffer.</p>
                <p>If you then call `nextLine()` immediately after `nextInt()` (or similar), `nextLine()` will simply
                    read that leftover newline character and think it has received an empty line, skipping your actual
                    input for that line.</p>

                <pre><code>
import java.util.Scanner;

public class NextLineTrapExample {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.println("--- Demonstrating the nextLine() Trap ---");

        System.out.print("Enter your favorite number: ");
        int favoriteNumber = scanner.nextInt(); // Reads the number, leaves '\n' in buffer

        System.out.print("Enter your favorite color: ");
        // PROBLEM: nextLine() reads the leftover '\n' from the previous nextInt()
        // and doesn't wait for you to type the color!
        String favoriteColor = scanner.nextLine(); // THIS LINE WILL BE SKIPPED

        System.out.println("\nYour favorite number is: " + favoriteNumber);
        System.out.println("Your favorite color is: " + favoriteColor); // This will likely be empty

        scanner.close();
    }
}
    </code></pre>
                <div class="output-box">
                    <b>Example Interaction (User Input is Bold):</b>
                    <pre>
--- Demonstrating the nextLine() Trap ---
Enter your favorite number: <b>7</b>
Enter your favorite color: 
(You don't get a chance to type the color here!)

Your favorite number is: 7
Your favorite color is: 
</pre>
                </div>

                <h4>Solution to the `nextLine()` Trap</h4>
                <p>To fix this, you need to "consume" or "eat" the leftover newline character after calling `nextInt()`,
                    `nextDouble()`, etc., but *before* calling `nextLine()`. You do this by adding an extra
                    `scanner.nextLine();` call immediately after the numeric/boolean input.</p>

                <pre><code>
import java.util.Scanner;

public class NextLineTrapSolution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.println("--- Solving the nextLine() Trap ---");

        System.out.print("Enter your favorite number: ");
        int favoriteNumber = scanner.nextInt();

        // SOLUTION: Add an extra nextLine() to consume the leftover newline character
        scanner.nextLine(); // <--- THIS IS THE FIX!

        System.out.print("Enter your favorite color: ");
        String favoriteColor = scanner.nextLine(); // Now this will correctly wait for your input

        System.out.println("\nYour favorite number is: " + favoriteNumber);
        System.out.println("Your favorite color is: " + favoriteColor);

        scanner.close();
    }
}
    </code></pre>
                <div class="output-box">
                    <b>Example Interaction (User Input is Bold):</b>
                    <pre>
--- Solving the nextLine() Trap ---
Enter your favorite number: <b>7</b>
Enter your favorite color: <b>Blue</b>

Your favorite number is: 7
Your favorite color is: Blue</pre>
                </div>

                <h4>More Useful `Scanner` Methods</h4>
                <p>The `Scanner` class is quite versatile and can be used to obtain data not just from the keyboard, but
                    also from files and strings. This table provides a comprehensive list of its useful methods,
                    including those for reading various data types (`nextXxx()`) and methods like `hasNextXxx()` which
                    are very helpful for validating input before attempting to read it.</p>

                <table>
                    <thead>
                        <tr>
                            <th>Method</th>
                            <th>Description</th>
                            <th>Return Type</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>close()</code></td>
                            <td>Closes the scanner object and releases any associated system resources.</td>
                            <td>`void`</td>
                        </tr>
                        <tr>
                            <td><code>delimiter()</code></td>
                            <td>Returns the `Pattern` this `Scanner` is currently using to separate tokens.</td>
                            <td>`Pattern`</td>
                        </tr>
                        <tr>
                            <td><code>findInLine(String pattern)</code></td>
                            <td>Attempts to find the next occurrence of the specified pattern ignoring delimiters.</td>
                            <td>`String`</td>
                        </tr>
                        <tr>
                            <td><code>findWithinHorizon(String pattern, int horizon)</code></td>
                            <td>Attempts to find the next occurrence of the specified pattern within the specified
                                search horizon.</td>
                            <td>`String`</td>
                        </tr>
                        <tr>
                            <td><code>hasNext()</code></td>
                            <td>Returns `true` if this scanner has another token in its input.</td>
                            <td>`boolean`</td>
                        </tr>
                        <tr>
                            <td><code>hasNextBoolean()</code></td>
                            <td>Returns `true` if the next token in this scanner's input can be interpreted as a boolean
                                value.</td>
                            <td>`boolean`</td>
                        </tr>
                        <tr>
                            <td><code>hasNextByte()</code></td>
                            <td>Returns `true` if the next token in this scanner's input can be interpreted as a `byte`
                                value.</td>
                            <td>`boolean`</td>
                        </tr>
                        <tr>
                            <td><code>hasNextDouble()</code></td>
                            <td>Returns `true` if the next token in this scanner's input can be interpreted as a
                                `double` value.</td>
                            <td>`boolean`</td>
                        </tr>
                        <tr>
                            <td><code>hasNextFloat()</code></td>
                            <td>Returns `true` if the next token in this scanner's input can be interpreted as a `float`
                                value.</td>
                            <td>`boolean`</td>
                        </tr>
                        <tr>
                            <td><code>hasNextInt()</code></td>
                            <td>Returns `true` if the next token in this scanner's input can be interpreted as an `int`
                                value.</td>
                            <td>`boolean`</td>
                        </tr>
                        <tr>
                            <td><code>hasNextLine()</code></td>
                            <td>Returns `true` if there is another line in the input of this scanner.</td>
                            <td>`boolean`</td>
                        </tr>
                        <tr>
                            <td><code>hasNextLong()</code></td>
                            <td>Returns `true` if the next token in this scanner's input can be interpreted as a `long`
                                value.</td>
                            <td>`boolean`</td>
                        </tr>
                        <tr>
                            <td><code>hasNextShort()</code></td>
                            <td>Returns `true` if the next token in this scanner's input can be interpreted as a `short`
                                value.</td>
                            <td>`boolean`</td>
                        </tr>
                        <tr>
                            <td><code>locale()</code></td>
                            <td>Returns the locale currently being used by this scanner.</td>
                            <td>`Locale`</td>
                        </tr>
                        <tr>
                            <td><code>next()</code></td>
                            <td>Finds and returns the next complete token from this scanner.</td>
                            <td>`String`</td>
                        </tr>
                        <tr>
                            <td><code>nextBoolean()</code></td>
                            <td>Scans the next token of the input as a `boolean`.</td>
                            <td>`boolean`</td>
                        </tr>
                        <tr>
                            <td><code>nextByte()</code></td>
                            <td>Scans the next token of the input as a `byte`.</td>
                            <td>`byte`</td>
                        </tr>
                        <tr>
                            <td><code>nextDouble()</code></td>
                            <td>Scans the next token of the input as a `double`.</td>
                            <td>`double`</td>
                        </tr>
                        <tr>
                            <td><code>nextFloat()</code></td>
                            <td>Scans the next token of the input as a `float`.</td>
                            <td>`float`</td>
                        </tr>
                        <tr>
                            <td><code>nextInt()</code></td>
                            <td>Scans the next token of the input as an `int`.</td>
                            <td>`int`</td>
                        </tr>
                        <tr>
                            <td><code>nextLine()</code></td>
                            <td>Advances this scanner past the current line and returns the input that was skipped.</td>
                            <td>`String`</td>
                        </tr>
                        <tr>
                            <td><code>nextLong()</code></td>
                            <td>Scans the next token of the input as a `long`.</td>
                            <td>`long`</td>
                        </tr>
                        <tr>
                            <td><code>nextShort()</code></td>
                            <td>Scans the next token of the input as a `short`.</td>
                            <td>`short`</td>
                        </tr>
                        <tr>
                            <td><code>radix()</code></td>
                            <td>Returns the default radix for this scanner.</td>
                            <td>`int`</td>
                        </tr>
                        <tr>
                            <td><code>reset()</code></td>
                            <td>Resets this scanner. Discarding any state, such as a delimiter, locale, or radix.</td>
                            <td>`Scanner`</td>
                        </tr>
                        <tr>
                            <td><code>useDelimiter(String pattern)</code></td>
                            <td>Sets this scanner's delimiting pattern.</td>
                            <td>`Scanner`</td>
                        </tr>
                        <tr>
                            <td><code>useLocale(Locale locale)</code></td>
                            <td>Sets this scanner's locale.</td>
                            <td>`Scanner`</td>
                        </tr>
                        <tr>
                            <td><code>useRadix(int radix)</code></td>
                            <td>Sets this scanner's default radix.</td>
                            <td>`Scanner`</td>
                        </tr>
                    </tbody>
                </table>

                <h4>Closing the `Scanner` (Important Nuance)</h4>
                <p>It's crucial to call `scanner.close()` when you are finished reading input from a `Scanner` that is
                    connected to a file or a network stream. This releases the underlying system resources associated
                    with that stream. However, there's a special consideration for `Scanner` objects connected to
                    `System.in`:</p>
                <ul>
                    <li>
                        <b>For `Scanner` with `System.in`:</b>
                        <p>Closing `scanner` connected to `System.in` also closes `System.in` itself. Since `System.in`
                            is a shared, global resource for your entire Java application, closing it in one part of
                            your code might prevent other parts (or other classes) from being able to read from the
                            keyboard later. In simple, single-threaded command-line programs, `scanner.close()` for
                            `System.in` is often done and is generally harmless. But in more complex applications, it's
                            safer to avoid closing `Scanner` connected to `System.in`, letting the JVM manage its
                            lifecycle when the program exits.</p>
                    </li>
                    <li>
                        <b>For `Scanner` with Files/Other Streams:</b>
                        <p><b>Always close these `Scanner` objects!</b> The best practice is to use a
                            `try-with-resources` statement, which automatically closes the scanner (and the underlying
                            file stream) for you, even if errors occur. This prevents resource leaks.</p>
                        <pre><code>
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class FileScannerExample {
    public static void main(String[] args) {
        // Example for file reading, where try-with-resources is essential
        try (Scanner fileScanner = new Scanner(new File("example.txt"))) {
            // This code will read from example.txt
            while (fileScanner.hasNextLine()) {
                System.out.println(fileScanner.nextLine());
            }
        } catch (FileNotFoundException e) {
            System.out.println("File not found: " + e.getMessage());
        }
        // fileScanner is automatically closed here!
    }
}
            </code></pre>
                    </li>
                </ul>

                <h4>Handling Invalid Input (Error Handling)</h4>
                <p>As mentioned, if the user types "hello" when your program expects an integer, methods like
                    `nextInt()` will throw an `<b>InputMismatchException</b>`. To make your program robust, you should
                    use a `try-catch` block to handle this, often combined with `hasNextXxx()` methods to check if the
                    next token matches the expected type before trying to read it.</p>

                <pre><code>
import java.util.InputMismatchException; // Don't forget this import!
import java.util.Scanner;

public class InputErrorHandling {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int age = 0;
        boolean validInput = false;

        System.out.println("--- Robust Age Input ---");

        while (!validInput) {
            System.out.print("Please enter your age (a whole number): ");
            try {
                age = scanner.nextInt(); // Try to read an integer
                validInput = true; // If successful, set flag to true to exit loop
            } catch (InputMismatchException e) {
                // If the user enters something that's not an int
                System.out.println("Invalid input! Please enter a number.");
                scanner.nextLine(); // IMPORTANT: Consume the invalid input line to prevent infinite loop
            }
        }

        System.out.println("Your age is: " + age);
        scanner.close();
        System.out.println("--- Program Finished ---");
    }
}
    </code></pre>
                <div class="output-box">
                    <b>Example Interaction (User Input is Bold):</b>
                    <pre>
--- Robust Age Input ---
Please enter your age (a whole number): <b>abc</b>
Invalid input! Please enter a number.
Please enter your age (a whole number): <b>twenty</b>
Invalid input! Please enter a number.
Please enter your age (a whole number): <b>25</b>
Your age is: 25
--- Program Finished ---</pre>
                </div>

                <p>By understanding these concepts, especially the `nextLine()` trap and basic error handling, you'll be
                    well-equipped to write interactive Java programs that gracefully handle user input.</p>


            </section>

            <section class="main-section" id="module2_oops">
                <header>
                    <h2>Module II: Object-Oriented Programming (OOP)</h2>
                </header>

                <p>Object-Oriented Programming (OOP) is a powerful programming paradigm that organizes software design
                    around "objects" rather than functions and logic. An object is a self-contained unit that
                    encapsulates both data (attributes or properties) and the procedures (methods) that operate on that
                    data. This approach aims to make software more modular, flexible, and maintainable.</p>

                <h3>Core Principles of OOP:</h3>
                <p>The foundation of OOP rests on four fundamental principles. Understanding these is key to mastering
                    object-oriented design.</p>
                <ul>
                    <li>
                        <strong>Encapsulation:</strong> This principle involves bundling the data (variables) and the
                        methods that operate on the data into a single unit, known as a class. It also includes
                        restricting direct access to some of an object's components, typically achieved using <b>access
                            modifiers</b> (like <mark>`private`</mark> , <mark>`public`</mark> ,
                        <mark>`protected`</mark> ). The primary benefit is data hiding,
                        preventing external code from directly manipulating an object's internal state, thus maintaining
                        data integrity and simplifying debugging.
                    </li>
                    <li>
                        <strong>Abstraction:</strong> Abstraction means hiding the complex implementation details and
                        showing only the essential features of an object or system. It allows you to focus on what an
                        object does rather than how it does it. In Java, abstraction is achieved through abstract
                        classes and interfaces, which define a contract for what methods a class must implement without
                        providing the implementation details.
                    </li>
                    <li>
                        <strong>Inheritance:</strong> Inheritance is a mechanism that allows a new class (subclass or
                        child class) to inherit properties (fields) and behaviors (methods) from an existing class
                        (superclass or parent class). This promotes code reusability and establishes a natural
                        <mark>"is-a"</mark>
                        relationship (e.g., a 'Dog' *is a* 'Animal'). In Java, the <mark>`extends`</mark> keyword is
                        used to achieve
                        inheritance.
                    </li>
                    <li>
                        <strong>Polymorphism:</strong> Meaning "many forms", polymorphism allows objects to take on
                        different forms. It enables a single interface or method to be used for different underlying
                        data types or classes. In Java, polymorphism is primarily achieved through:
                        <ul>
                            <li><strong>Method Overloading (Compile-time Polymorphism):</strong> Defining multiple
                                methods in the same class with the same name but different parameters (different number
                                or types of arguments).</li>
                            <li><strong>Method Overriding (Runtime Polymorphism):</strong> Redefining a method of a
                                superclass in its subclass. The specific method to be called is determined at runtime
                                based on the actual object type.</li>
                        </ul>
                    </li>
                </ul>

                <h3>Key OOP Concepts in Java with Examples:</h3>

                <div class="code-example">
                    <h3>1. Class & Object</h3>
                    <p>A <strong>Class</strong> is a blueprint or a template for creating objects. It defines the common
                        properties (data) and behaviors (methods) that all objects of that type will have. An
                        <strong>Object</strong> is an instance of a class, a concrete realization of that blueprint.
                    </p>
                    <pre><code class="language-java">
// Class definition: Student blueprint
public class Student {
    // Instance variables (attributes)
    private String name;
    private int age;
    private double gpa;

    // Constructor (special method to initialize objects)
    public Student(String name, int age, double gpa) {
        this.name = name; // 'this' refers to the current object's instance variable
        this.age = age;
        this.gpa = gpa;
    }

    // Method (behavior)
    public void displayInfo() {
        System.out.println("Name: " + name + ", Age: " + age + ", GPA: " + gpa);
    }

    // Getters and Setters (for controlled access to private data - Encapsulation)
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public int getAge() { return age; }
    public void setAge(int age) { this.age = age; }
    public double getGpa() { return gpa; }
    public void setGpa(double gpa) { this.gpa = gpa; }

    public static void main(String[] args) {
        // Creating objects (instances) of the Student class
        Student student1 = new Student("Alice", 20, 3.8); // Calls the constructor
        Student student2 = new Student("Bob", 19, 3.5);

        // Calling methods on objects
        student1.displayInfo();
        student2.displayInfo();

        // Using a setter to modify an object's state
        student1.setGpa(3.9);
        System.out.println("Alice's new GPA: " + student1.getGpa());
    }
}
        </code></pre>
                    <div class="output">
                        <h4>Output:</h4>
                        <pre><code>Name: Alice, Age: 20, GPA: 3.8
Name: Bob, Age: 19, GPA: 3.5
Alice's new GPA: 3.9</code></pre>
                    </div>
                </div>

                <div class="code-example">
                    <h3>2. Constructors</h3>
                    <p>A <strong>Constructor</strong> is a special type of method used to initialize objects. It has the
                        same name as the class and does not have a return type. Constructors are called automatically
                        when an object is created using the `new` keyword. A class can have multiple constructors
                        (constructor overloading) to allow for different ways of initializing objects.</p>
                    <pre><code class="language-java">
public class Car {
    private String brand;
    private String model;
    private int year;

    // Default Constructor (no parameters)
    public Car() {
        this.brand = "Unknown";
        this.model = "Unknown";
        this.year = 0;
        System.out.println("Default Car created.");
    }

    // Parameterized Constructor
    public Car(String brand, String model, int year) {
        this.brand = brand;
        this.model = model;
        this.year = year;
        System.out.println("Parameterized Car created: " + brand + " " + model);
    }

    // Constructor Overloading: Another parameterized constructor
    public Car(String brand, String model) {
        this(brand, model, 2024); // Calls the other three-parameter constructor ('this()' for constructor chaining)
        System.out.println("Two-parameter Car created: " + brand + " " + model);
    }

    public void displayCarDetails() {
        System.out.println("Brand: " + brand + ", Model: " + model + ", Year: " + year);
    }

    public static void main(String[] args) {
        Car car1 = new Car(); // Calls the default constructor
        car1.displayCarDetails();

        Car car2 = new Car("Toyota", "Camry", 2022); // Calls the three-parameter constructor
        car2.displayCarDetails();

        Car car3 = new Car("Honda", "Civic"); // Calls the two-parameter constructor
        car3.displayCarDetails();
    }
}
        </code></pre>
                    <div class="output">
                        <h4>Output:</h4>
                        <pre><code>Default Car created.
Brand: Unknown, Model: Unknown, Year: 0
Parameterized Car created: Toyota Camry
Brand: Toyota, Model: Camry, Year: 2022
Parameterized Car created: Honda Civic
Two-parameter Car created: Honda Civic
Brand: Honda, Model: Civic, Year: 2024</code></pre>
                    </div>
                </div>

                <div class="code-example">
                    <h3>3. Method Overloading & Overriding (Polymorphism)</h3>
                    <p><strong>Method Overloading</strong> enables a class to have multiple methods with the same name,
                        but they must differ in the number or type of their parameters. This is an example of
                        compile-time polymorphism.</p>
                    <p><strong>Method Overriding</strong> occurs when a subclass provides its own specific
                        implementation for a method that is already defined in its superclass. This is an example of
                        runtime polymorphism, as the method to be executed is determined at runtime based on the actual
                        object type.</p>
                    <pre><code class="language-java">
// Method Overloading example
class Calculator {
    public int add(int a, int b) { // Method 1
        return a + b;
    }

    public double add(double a, double b) { // Method 2: Same name, different parameter types
        return a + b;
    }

    public int add(int a, int b, int c) { // Method 3: Same name, different number of parameters
        return a + b + c;
    }

    public static void main(String[] args) {
        Calculator calc = new Calculator();
        System.out.println("Sum of two integers: " + calc.add(5, 10));
        System.out.println("Sum of two doubles: " + calc.add(5.5, 10.2));
        System.out.println("Sum of three integers: " + calc.add(1, 2, 3));
    }
}

// Method Overriding example
class Animal { // Superclass
    public void makeSound() {
        System.out.println("Animal makes a generic sound");
    }
}

class Dog extends Animal { // Subclass
    @Override // Annotation to indicate method overriding
    public void makeSound() { // Overrides the makeSound() method from Animal
        System.out.println("Dog barks: Woof woof!");
    }

    public static void main(String[] args) {
        Animal myAnimal = new Animal();
        myAnimal.makeSound();

        Dog myDog = new Dog();
        myDog.makeSound();

        // Polymorphism in action: An Animal reference variable holding a Dog object
        Animal polymorphicAnimal = new Dog();
        polymorphicAnimal.makeSound();
    }
}
        </code></pre>
                    <div class="output">
                        <h4>Output (for Calculator):</h4>
                        <pre><code>Sum of two integers: 15
Sum of two doubles: 15.7
Sum of three integers: 6</code></pre>
                        <h4>Output (for Animal/Dog):</h4>
                        <pre><code>Animal makes a generic sound
Dog barks: Woof woof!
Dog barks: Woof woof!</code></pre>
                    </div>
                </div>

                <div class="code-example">
                    <h3>4. Encapsulation</h3>
                    <p>Encapsulation is achieved by declaring the instance variables of a class as `private` and
                        providing public methods (getters and setters) to access and modify these variables. This
                        protects the data from unauthorized direct access and allows for control over how the data is
                        manipulated.</p>
                    <pre><code class="language-java">
public class BankAccount {
    private double balance; // Private: Data is hidden
    private String accountNumber;

    public BankAccount(String accountNumber, double initialBalance) {
        this.accountNumber = accountNumber;
        // Business logic can be applied here to validate initialBalance
        if (initialBalance >= 0) {
            this.balance = initialBalance;
        } else {
            this.balance = 0;
            System.err.println("Initial balance cannot be negative. Setting to 0.");
        }
    }

    // Public getter method to read balance
    public double getBalance() {
        return balance;
    }

    // Public method to deposit (controlled access)
    public void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
            System.out.println("Deposited: " + amount + ". New balance: " + balance);
        } else {
            System.out.println("Deposit amount must be positive.");
        }
    }

    // Public method to withdraw (controlled access with logic)
    public boolean withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;
            System.out.println("Withdrew: " + amount + ". New balance: " + balance);
            return true;
        } else {
            System.out.println("Invalid withdrawal amount or insufficient balance.");
            return false;
        }
    }

    public static void main(String[] args) {
        BankAccount myAccount = new BankAccount("123456789", 1000.0);
        // myAccount.balance = -500; // This would cause a compile-time error due to 'private' access

        System.out.println("Current balance: " + myAccount.getBalance()); // Access via getter

        myAccount.deposit(200.0);
        myAccount.withdraw(150.0);
        myAccount.withdraw(2000.0); // Will fail due to insufficient balance
        myAccount.deposit(-50.0); // Will fail due to invalid amount
    }
}
        </code></pre>
                    <div class="output">
                        <h4>Output:</h4>
                        <pre><code>Current balance: 1000.0
Deposited: 200.0. New balance: 1200.0
Withdrew: 150.0. New balance: 1050.0
Invalid withdrawal amount or insufficient balance.
Deposit amount must be positive.</code></pre>
                    </div>
                </div>

                <div class="code-example">
                    <h3>5. Inheritance</h3>
                    <p>Inheritance allows a class (child/subclass) to acquire the properties and methods of another
                        class (parent/superclass). This mechanism facilitates code reuse and models "is-a" relationships
                        in your domain.</p>
                    <pre><code class="language-java">
// Parent class (Superclass)
class Vehicle {
    String brand = "Generic Vehicle";

    void drive() {
        System.out.println("The vehicle is moving.");
    }

    void honk() {
        System.out.println("Vehicle honks.");
    }
}

// Child class (Subclass) inheriting from Vehicle
class Car extends Vehicle {
    String model = "Sedan"; // Car has its own specific attributes

    // Car can also have its own methods
    void accelerate() {
        System.out.println("The car is accelerating.");
    }

    // Method overriding: Car provides its own implementation of honk()
    @Override
    void honk() {
        System.out.println("Car honks: Beep beep!");
    }

    public static void main(String[] args) {
        Car myCar = new Car();

        // Accessing inherited properties and methods
        System.out.println("My car brand: " + myCar.brand);
        myCar.drive();

        // Accessing its own properties and methods
        System.out.println("My car model: " + myCar.model);
        myCar.accelerate();

        // Calling the overridden method
        myCar.honk();
    }
}
        </code></pre>
                    <div class="output">
                        <h4>Output:</h4>
                        <pre><code>My car brand: Generic Vehicle
The vehicle is moving.
My car model: Sedan
The car is accelerating.
Car honks: Beep beep!</code></pre>
                    </div>
                </div>

                <div class="code-example">
                    <h3>6. Abstraction (Abstract Classes and Interfaces)</h3>
                    <p>Abstraction is about representing essential features without including the background details or
                        explanations. In Java, this is primarily achieved through abstract classes and interfaces.</p>

                    <h4>Abstract Class:</h4>
                    <p>An `abstract` class cannot be instantiated directly (you cannot create objects of an abstract
                        class). It can contain both abstract methods (methods without a body, declared with `abstract`
                        keyword) and concrete methods (methods with a body). Subclasses must provide implementations for
                        all abstract methods inherited from the abstract class.</p>
                    <pre><code class="language-java">
// Abstract class
abstract class Shape {
    String color; // Can have instance variables

    // Abstract method (no body), must be implemented by concrete subclasses
    abstract void draw();

    // Concrete method (with a body)
    void displayColor() {
        System.out.println("Shape color: " + color);
    }

    public Shape(String color) { // Can have constructors
        this.color = color;
    }
}

// Concrete subclass extending an abstract class
class Circle extends Shape {
    public Circle(String color) {
        super(color); // Call to superclass constructor
    }

    @Override
    void draw() { // Must implement the abstract draw() method
        System.out.println("Drawing a circle with color: " + color);
    }

    public static void main(String[] args) {
        // Shape myShape = new Shape("Red"); // Compile-time error: Cannot instantiate abstract class

        Shape circle = new Circle("Blue"); // Polymorphism: Reference of abstract class, object of concrete class
        circle.draw();
        circle.displayColor();
    }
}
        </code></pre>
                    <div class="output">
                        <h4>Output:</h4>
                        <pre><code>Drawing a circle with color: Blue
Shape color: Blue</code></pre>
                    </div>

                    <h4>Interface:</h4>
                    <p>An `interface` in Java is a blueprint of a class. It can contain method signatures (implicitly
                        `public abstract` before Java 8), default methods, static methods, and constant fields
                        (implicitly `public static final`). Interfaces are used to achieve 100% abstraction and to
                        support multiple inheritance of type (a class can implement multiple interfaces).</p>
                    <pre><code class="language-java">
// Interface definition
interface Drawable {
    // Before Java 8: methods were implicitly public abstract
    void draw();

    // From Java 8: default methods can have implementation
    default void resize() {
        System.out.println("Resizing the drawable object.");
    }

    // From Java 8: static methods can be defined in interfaces
    static void showInfo() {
        System.out.println("This is a drawable interface.");
    }
}

// Class implementing an interface
class Rectangle implements Drawable {
    @Override
    public void draw() { // Must implement the draw method
        System.out.println("Drawing Rectangle.");
    }

    public static void main(String[] args) {
        Rectangle rect = new Rectangle();
        rect.draw();
        rect.resize();

        Drawable.showInfo();
    }
}

class Triangle implements Drawable {
    @Override
    public void draw() {
        System.out.println("Drawing Triangle.");
    }

    public static void main(String[] args) {
        Drawable d = new Triangle(); // Polymorphism
        d.draw();
    }
}
        </code></pre>
                    <div class="output">
                        <h4>Output (for Rectangle):</h4>
                        <pre><code>Drawing Rectangle.
Resizing the drawable object.
This is a drawable interface.</code></pre>
                        <h4>Output (for Triangle):</h4>
                        <pre><code>Drawing Triangle.</code></pre>
                    </div>
                </div>

                <div class="code-example">
                    <h3>7. `this` and `super` Keywords</h3>
                    <p>The `this` and `super` keywords are crucial for managing references within classes and their
                        inheritance hierarchies.</p>
                    <ul>
                        <li>
                            <strong>`this` keyword:</strong> Refers to the current instance of the class. It is used to:
                            <ul>
                                <li>Refer to the current class's instance variables (e.g., `this.name = name;` to
                                    differentiate between an instance variable and a parameter with the same name).</li>
                                <li>Invoke the current class's method (e.g., `this.display();`).</li>
                                <li>Invoke the current class's constructor (constructor chaining, e.g., `this(arg1,
                                    arg2);`).</li>
                                <li>Pass the current instance as an argument to a method.</li>
                            </ul>
                        </li>
                        <li>
                            <strong>`super` keyword:</strong> Refers to the immediate parent (superclass) instance. It
                            is used to:
                            <ul>
                                <li>Access the superclass's instance variables (e.g., `super.color`).</li>
                                <li>Invoke the superclass's method (e.g., `super.makeSound();`).</li>
                                <li>Invoke the superclass's constructor (e.g., `super(arguments);` - must be the first
                                    statement in the subclass constructor).</li>
                            </ul>
                        </li>
                    </ul>
                    <pre><code class="language-java">
class Animal {
    String color = "white"; // Instance variable in parent class

    Animal(String color) {
        this.color = color; // 'this' refers to Animal's color
    }

    void printColor() {
        System.out.println("Animal color: " + this.color);
    }
}

class Dog extends Animal {
    String color = "black"; // Instance variable in child class (shadows parent's color)

    Dog(String animalColor, String dogColor) {
        super(animalColor); // Calls the parent (Animal) constructor
        this.color = dogColor; // 'this' refers to Dog's color
    }

    void displayColors() {
        System.out.println("Dog's color: " + this.color);
        System.out.println("Animal's color: " + super.color);
        super.printColor(); // Calls printColor() from the parent (Animal) class
    }

    public static void main(String[] args) {
        Dog myDog = new Dog("Brown (from Animal)", "Black (from Dog)");
        myDog.displayColors();
    }
}

// Example for 'this()' constructor chaining
class Person {
    String name;
    int age;

    Person(String name) {
        this.name = name; // 'this' refers to the instance variable
        System.out.println("Person created with name: " + name);
    }

    Person(String name, int age) {
        this(name); // Calls the single-parameter constructor of the current class
        this.age = age;
        System.out.println("Person created with name: " + name + " and age: " + age);
    }

    public static void main(String[] args) {
        Person p1 = new Person("Alice");
        Person p2 = new Person("Bob", 30);
    }
}
        </code></pre>
                    <div class="output">
                        <h4>Output (for Animal/Dog):</h4>
                        <pre><code>Dog's color: Black (from Dog)
Animal's color: Brown (from Animal)
Animal color: Brown (from Animal)</code></pre>
                        <h4>Output (for Person):</h4>
                        <pre><code>Person created with name: Alice
Person created with name: Bob
Person created with name: Bob and age: 30</code></pre>
                    </div>
                </div>

                <div class="code-example">
                    <h3>8. Static Keyword</h3>
                    <p>The `static` keyword in Java is used to declare members (variables, methods, blocks, and nested
                        classes) that belong to the class itself, rather than to any specific instance (object) of the
                        class. This means static members are shared across all instances of a class and can be accessed
                        directly using the class name, without creating an object.</p>
                    <pre><code class="language-java">
class Counter {
    static int instanceCount = 0; // Static variable: shared by all objects

    Counter() {
        instanceCount++; // Incremented for every new object created
        System.out.println("New object created. Total objects: " + instanceCount);
    }

    static void displayTotalObjects() { // Static method: belongs to the class
        System.out.println("Total Counter objects created so far: " + instanceCount);
    }

    public static void main(String[] args) {
        System.out.println("Initial count: " + Counter.instanceCount);

        Counter c1 = new Counter(); // Creates object 1
        Counter c2 = new Counter(); // Creates object 2
        Counter c3 = new Counter(); // Creates object 3

        Counter.displayTotalObjects();
    }
}

// Example of a static utility method (like in Math class)
class MathUtils {
    public static int add(int a, int b) { // A static method
        return a + b;
    }

    public static void main(String[] args) {
        // Call static method directly using class name
        int sum = MathUtils.add(10, 20);
        System.out.println("Sum using static method: " + sum);
    }
}
        </code></pre>
                    <div class="output">
                        <h4>Output (for Counter):</h4>
                        <pre><code>Initial count: 0
New object created. Total objects: 1
New object created. Total objects: 2
New object created. Total objects: 3
Total Counter objects created so far: 3</code></pre>
                        <h4>Output (for MathUtils):</h4>
                        <pre><code>Sum using static method: 30</code></pre>
                    </div>
                </div>

                <div class="highlight">
                    <p><strong>Note:</strong> Java is not a purely object-oriented language because it supports
                        primitive data types (like int, char, etc.) that are not objects. However, it is often referred
                        to as an object-oriented language due to its strong emphasis on OOP principles.</p>
                </div>

            </section>

            <section class="main-section" id="module3_collections">
                <header>
                    <h2>Module III: Collections</h2>
                </header>

                <p>The Java Collections Framework is a set of interfaces and classes that provide a unified architecture
                    for representing and manipulating groups of objects. It offers various data structures and
                    algorithms, reducing programming effort and improving performance. The framework includes interfaces
                    like <i><b>Collection, List, Set, and Map,</b></i> along with concrete implementations such as
                    <i><b>ArrayList,
                            LinkedList, HashSet, TreeSet, and HashMap</b></i>. These implementations offer different
                    performance
                    characteristics and are suitable for various use cases. The framework also provides algorithms for
                    searching, sorting, and other common operations on collections.
                </p>

                <h3>1. List, Set, and Map</h3>
                <p>Collections framework provides various classes like List, Set, and Map to store and manipulate
                    groups of objects.</p>

                <pre><code>
import java.util.*;
public class CollectionExample {
    public static void main(String[] args) {
        // List example
        List<String> list = new ArrayList<>();
        list.add("Apple");
        list.add("Banana");
        list.add("Orange");
        System.out.println("List: " + list);

        // Set example
        Set<Integer> set = new HashSet<>();
        set.add(1);
        set.add(2);
        set.add(3);
        set.add(1); // Duplicate, will not be added
        System.out.println("Set: " + set);

        // Map example
        Map<String, Integer> map = new HashMap<>();
        map.put("one", 1);
        map.put("two", 2);
        map.put("three", 3);
        System.out.println("Map: " + map);
    }
}
    </code></pre>

                <h3>2. Iterator & Enhanced For Loop</h3>
                <p>Used to iterate through collections easily.</p>

                <pre><code>
// Iterator
List<String> names = new ArrayList<>();
names.add("Alice");
names.add("Bob");

Iterator<String> itr = names.iterator();
while (itr.hasNext()) {
    System.out.println(itr.next());
}

// Enhanced For Loop
for (String name : names) {
    System.out.println(name);
}
    </code></pre>

                <h3>3. Sorting with Collections</h3>
                <p>Sort collections using utility methods or comparators.</p>

                <pre><code>
List<Integer> numbers = Arrays.asList(5, 3, 8, 1);
Collections.sort(numbers);
System.out.println(numbers);

Collections.sort(numbers, Collections.reverseOrder());
System.out.println(numbers);
    </code></pre>

                <h3>4. Comparable & Comparator</h3>
                <p>Interfaces to define natural and custom sorting order.</p>

                <pre><code>
class Student implements Comparable<Student> {
    int id;
    String name;

    Student(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int compareTo(Student s) {
        return this.id - s.id; // Ascending order
    }
}

// Comparator<br>
class NameComparator implements Comparator<Student> {
    public int compare(Student s1, Student s2) {
        return s1.name.compareTo(s2.name);
    }
}

Collections.sort(studentList, new NameComparator());
    </code></pre>

                <div class="highlight">
                    <p><strong>Note:</strong> "Collections" provide the ready-to-use tools, they are a fundamental part
                        of Data Structures
                        and Algorithms (DSA), which is the study of how to organize and process data efficiently.
                        Understanding collections
                        is key to mastering DSA, as they demonstrate the practical application of different data
                        structures and their
                        associated algorithms.</p>
                </div>
            </section>

            <section class="main-section" id="module4_gui">
                <header>
                    <h2>Module IV: GUI</h2>
                </header>

                <h3>1. Introduction to Swing</h3>
                <p>Swing is a GUI widget toolkit for Java that provides a rich set of components for building graphical
                    interfaces. Developed by Sun Microsystems (now Oracle), Swing was introduced as part of the Java
                    Foundation Classes (JFC) and represents a significant evolution from its predecessor, AWT (Abstract
                    Window Toolkit).</p>

                <h3>2. Key Characteristics of Swing:</h3>
                <ul>
                    <li>
                        <strong>Platform Independence (Lightweight Components):</strong> Unlike AWT components which are
                        "heavyweight" and rely on the underlying operating system's native peer components, Swing
                        components are "lightweight." This means they are largely drawn by Java code rather than by the
                        OS, leading to a consistent look and feel across different platforms (Windows, macOS, Linux) and
                        greater flexibility in customization. This "write once, run anywhere" philosophy is central to
                        Java.
                    </li>
                    <li>
                        <strong>Rich Set of Components:</strong> Swing offers a comprehensive library of pre-built GUI
                        components, including buttons <mark>JButton</mark>, text fields <mark>JTextField</mark>, labels
                        <mark>JLabel</mark>, checkboxes <mark>JCheckBox</mark>, radio buttons <mark>JRadioButton</mark>,
                        menus <mark>JMenu</mark> <mark>JMenuItem</mark>, tables <mark>JTable</mark>, trees
                        <mark>JTree</mark>, tabbed panes <mark>JTabbedPane</mark>, and more. These components are
                        designed to be flexible and extensible.
                    </li>
                    <li>
                        <strong>Pluggable Look and Feel (L&F):</strong> Swing allows developers to change the appearance
                        of the GUI without modifying the underlying code. This is achieved through Pluggable Look and
                        Feel. You can make a Swing application look like a native Windows application, a macOS
                        application, or use Java's own "Metal" (or "Ocean") L&F, or even create custom L&Fs. This
                        enhances user experience by allowing applications to blend in with the user's preferred desktop
                        theme.
                    </li>
                    <li>
                        <strong>Model-View-Controller (MVC) Architecture:</strong> Many Swing components are designed
                        around a modified MVC architecture. This separation of concerns means that the data (model), its
                        visual representation (view), and the handling of user interactions (controller) are distinct.
                        This design promotes code reusability, modularity, and easier maintenance. For instance, a
                        <mark>JTable</mark>'s data is managed by a <mark>TableModel</mark>, its
                        appearance by a <mark>TableCellRenderer</mark>, and user input by a
                        <mark>TableCellEditor</mark>.
                    </li>
                    <li>
                        <strong>Event-Driven Programming:</strong> Swing applications are inherently event-driven. User
                        interactions (like button clicks, mouse movements, key presses) generate events. Developers
                        write event listeners that respond to these specific events, allowing the application to react
                        dynamically to user input. This paradigm makes GUIs interactive and responsive.
                    </li>
                    <li>
                        <strong>Accessibility Features:</strong> Swing provides features that aid in making applications
                        accessible to users with disabilities, such as support for screen readers and keyboard
                        navigation.
                    </li>
                </ul>

                <div class="highlight">
                    <p><strong>Note: </strong>While newer UI toolkits like JavaFX have emerged, Swing remains a robust
                        and widely used framework
                        for developing desktop applications in Java, especially for enterprise-level software due to its
                        maturity and extensive component library.</p>
                </div>

                <pre><code>
import javax.swing.*; // Imports all classes from the Swing package

public class SimpleGUI {
    public static void main(String[] args) {
        // 1. Create the top-level container (window)
        // JFrame is a top-level container that represents the main window of a Swing application.
        JFrame frame = new JFrame("My First GUI");

        // 2. Create a component to be placed inside the frame
        // JButton is a push button component. When clicked, it generates an ActionEvent.
        JButton button = new JButton("Click Me");

        // 3. Set the default close operation for the frame
        // JFrame.EXIT_ON_CLOSE ensures that the application terminates when the user closes the window.
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        // 4. Add the component to the frame's content pane
        // The content pane is the main area of the JFrame where components are added.
        frame.getContentPane().add(button); // Adds the button to the default (CENTER) position of the content pane's BorderLayout

        // 5. Set the size of the frame
        // Sets the width and height of the window in pixels.
        frame.setSize(300, 200);

        // 6. Make the frame visible
        // By default, JFrames are not visible. This line makes the window appear on the screen.
        frame.setVisible(true);
    }
}
    </code></pre>
            </section>

            <section class="main-section" id="module5_database">
                <header>
                    <h2>Module V: Database</h2>
                </header>

                <h3>1. JDBC Basics</h3>
                <p>Java Database Connectivity (JDBC) is an <strong>API (Application Programming Interface)</strong> for
                    connecting and executing queries on a database. It serves as a standard for Java applications to
                    interact with various <strong>relational database management systems (RDBMS)</strong> like
                    <i><b>MySQL,
                            Oracle, PostgreSQL, SQL Server, and more</b></i>.
                </p>

                <h3>2. Purpose and Importance of JDBC</h3>
                <p>JDBC acts as a crucial bridge, allowing Java programs to communicate with a wide range of databases
                    without needing to know the intricate details of each database's specific communication protocols.
                    This provides <strong>database independence</strong>, meaning you can write Java code once and run
                    it against different databases simply by changing the JDBC driver and connection URL. It
                    standardizes how Java applications perform common database operations, such as <strong>connecting to
                        a database, executing SQL statements, and processing the results</strong>.</p>

                <h3>3. How JDBC Works: The Role of Drivers</h3>
                <p>At the heart of JDBC's functionality are <strong>JDBC drivers</strong>. These are software components
                    that translate the generic JDBC API calls made by your Java application into the specific network
                    protocols and SQL dialects understood by a particular database. When you use JDBC, you're
                    interacting with these drivers, which then handle the low-level communication. Database vendors
                    supply these drivers (e.g., MySQL Connector/J for MySQL, Oracle JDBC Driver for Oracle databases).
                    This layered approach ensures that your Java application remains independent of the database's
                    internal workings.</p>

                <h3>4. Key Capabilities Provided by JDBC</h3>
                <p>JDBC offers a comprehensive set of features for database interaction:</p>
                <ul>
                    <li><strong>Establishing and Managing Connections:</strong> It provides mechanisms to open and close
                        connections to databases, handling connection pooling for efficient resource management.</li>
                    <li><strong>Executing SQL Statements:</strong> You can send various types of SQL statements,
                        including:
                        <ul>
                            <li><strong>DML (Data Manipulation Language):</strong> For operations like
                                <strong>SELECT</strong>
                                (retrieving data), <strong>INSERT</strong> (adding data), <strong>UPDATE</strong>
                                (modifying data), and <strong>DELETE</strong> (removing data).
                            </li>
                            <li><strong>DDL (Data Definition Language):</strong> For defining or modifying database
                                schemas, such as
                                <strong>CREATE TABLE</strong>, <strong>ALTER TABLE</strong>, and <strong>DROP
                                    TABLE</strong>.
                            </li>
                            <li><strong>Stored Procedures:</strong> Support for executing pre-compiled routines stored
                                within the
                                database.</li>
                        </ul>
                    </li>
                    <li><strong>Processing Result Sets:</strong> After executing a SELECT query, JDBC provides a
                        <strong>ResultSet</strong> object that allows you to efficiently navigate through the returned
                        rows and retrieve data from individual columns by name or index.
                    </li>
                    <li><strong>Transaction Management:</strong> JDBC supports database transactions, allowing you to
                        group multiple SQL operations into a single atomic unit. This ensures data consistency; either
                        all operations within the transaction succeed, or none of them do (if a rollback occurs).</li>
                    <li><strong>Error Handling:</strong> It defines a robust exception hierarchy (centered around
                        <strong>SQLException</strong>) to handle database-specific errors and warnings, enabling
                        reliable application development.
                    </li>
                </ul>

                <div class="highlight">
                    <p><strong>Note: </strong>In essence, JDBC provides the essential framework for Java applications to
                        perform all necessary
                        interactions with relational databases, making it a cornerstone for developing data-driven
                        enterprise applications.</p>
                </div>

                <pre><code>
import java.sql.*;

public class JdbcExample {
    public static void main(String[] args) throws Exception {
        Class.forName("com.mysql.cj.jdbc.Driver");
        Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/dbname", "user", "pass");
        Statement stmt = con.createStatement();
        ResultSet rs = stmt.executeQuery("SELECT * FROM users");

        while (rs.next()) {
            System.out.println(rs.getString(1) + " " + rs.getString(2));
        }
        con.close();
    }
}
    </code></pre>
            </section>

            <section class="main-section" id="module6_spring_boot">
                <header>
                    <h2>Module VI: Spring Boot</h2>
                </header>

                <h3>1. Spring Boot Basics</h3>
                <p>Spring Boot simplifies the setup of Spring applications with default configurations and embedded
                    servers. It's an opinionated framework that aims to <b>get Spring applications up and running with
                        minimal effort</b>, reducing the boilerplate code and configuration often associated with
                    traditional
                    Spring development.</p>

                <h4>Why Spring Boot? The Problem It Solves</h4>
                <p>Before Spring Boot, setting up a Spring application, especially a web application, often involved
                    significant manual configuration (XML or Java-based), dependency management, and server setup (like
                    deploying to Tomcat). This could be time-consuming and error-prone. Spring Boot addresses these
                    challenges by:</p>
                <ul>
                    <li><strong>Reducing Boilerplate Code:</strong> It leverages conventions over configuration,
                        drastically cutting down the amount of code developers need to write for common functionalities.
                    </li>
                    <li><strong>Simplifying Configuration:</strong> Through auto-configuration, Spring Boot
                        intelligently configures your application based on the dependencies you include in your project.
                        This means less manual configuration is required.</li>
                    <li><strong>Embedded Servers:</strong> It includes embedded servlet containers like <b>Tomcat,
                            Jetty,
                            or Undertow</b> directly within the executable JAR, eliminating the need for external server
                        installations and deployments. This makes applications self-contained and easier to run.</li>
                    <li><strong>Opinionated Defaults:</strong> Spring Boot makes sensible default choices for various
                        configurations, allowing developers to start quickly. If needed, these defaults can be easily
                        overridden.</li>
                    <li><strong>Production-Ready Features:</strong> It provides features like externalized
                        configuration, health checks, metrics, and monitoring tools (via Spring Boot Actuator) that are
                        crucial for deploying applications to production environments.</li>
                </ul>

                <h4>Key Features and Concepts of Spring Boot</h4>
                <ul>
                    <li>
                        <strong>Auto-Configuration:</strong> This is a cornerstone of Spring Boot. Based on the JAR
                        dependencies present in your classpath, Spring Boot automatically configures many aspects of
                        your application. For example, if you add the `spring-boot-starter-web` dependency, it
                        auto-configures Spring MVC, an embedded Tomcat server, and necessary dispatchers.
                    </li>
                    <li>
                        <strong>Spring Boot Starters:</strong> These are convenient dependency descriptors that you can
                        include in your project. Each starter brings a set of transitive dependencies that are commonly
                        used together for a particular functionality (e.g., `spring-boot-starter-data-jpa` for database
                        access, `spring-boot-starter-test` for testing). They simplify dependency management
                        significantly.
                    </li>
                    <li>
                        <strong>No XML Configuration:</strong> While Spring Framework itself supports Java-based
                        configuration, Spring Boot heavily promotes and facilitates entirely XML-free development,
                        relying on Java configurations and annotations.
                    </li>
                    <li>
                        <strong>Embedded Servers:</strong> As mentioned, Spring Boot applications can run as standalone
                        JARs with built-in servers (Tomcat, Jetty, Undertow). This removes the need for traditional WAR
                        file deployments.
                    </li>
                    <li>
                        <strong>Spring Boot Actuator:</strong> This module provides production-ready features to monitor
                        and manage your application. It offers various endpoints (e.g., `/health`, `/info`, `/metrics`)
                        to inspect application health, configuration, environment, and more.
                    </li>
                    <li>
                        <strong>Externalized Configuration:</strong> Spring Boot allows you to externalize your
                        configuration (e.g., database connection details, server ports) in various ways
                        (application.properties, application.yml, environment variables, command-line arguments), making
                        it easy to run the same application in different environments without code changes.
                    </li>
                    <li>
                        <strong>Command-Line Interface (CLI):</strong> Spring Boot provides a CLI tool that you can use
                        to quickly create Spring projects from the command line, run Groovy scripts, and manage
                        dependencies.
                    </li>
                </ul>

                <div class="highlight">
                    <p><strong>Note: </strong>By abstracting away much of the initial setup and configuration, Spring
                        Boot allows developers to
                        focus more on writing business logic and less on infrastructure, significantly accelerating the
                        development of robust, production-ready Spring applications.</p>
                </div>

                <h3>2. Spring Boot Annotations</h3>
                <p>Annotations are fundamental to Spring Boot, providing metadata that tells Spring how to configure and
                    manage your application's components. They significantly reduce the need for XML configuration,
                    making code cleaner and more readable. Here are a few essential Spring Boot annotations:</p>
                <ul>
                    <li>
                        <strong>@SpringBootApplication:</strong> This is a convenience annotation that marks the main
                        class of a Spring Boot application. It's a meta-annotation that combines three other important
                        annotations:
                        <ul>
                            <li><strong>@Configuration:</strong> Designates a class as a source of bean definitions for
                                the Spring application context.</li>
                            <li><strong>@EnableAutoConfiguration:</strong> Tells Spring Boot to start adding beans based
                                on classpath settings, other beans, and various property settings. This is where the
                                magic of auto-configuration happens.</li>
                            <li><strong>@ComponentScan:</strong> Instructs Spring to scan for components (like
                                controllers, services, repositories) in the current package and its sub-packages,
                                automatically registering them as beans.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>@RestController:</strong> A specialized version of <b>@Controller</b> that's used in
                        RESTful web services. It combines <b>@Controller</b> and <b>@ResponseBody</b>, meaning that
                        methods
                        within this class will directly return data (e.g., JSON or XML) instead of views.
                    </li>
                    <li>
                        <strong>@Service:</strong> Marks a class as a service component, typically holding business
                        logic. It's a specialization of <b>@Component</b>.
                    </li>
                    <li>
                        <strong>@Repository:</strong> Marks a class as a Data Access Object (DAO), indicating that it
                        deals with data storage, retrieval, and manipulation. It also provides automatic exception
                        translation. It's another specialization of <b>@Component</b>.
                    </li>
                    <li>
                        <strong>@Autowired:</strong> Used for automatic dependency injection. When you annotate a field,
                        constructor, or setter method with <b>@Autowired</b>, Spring automatically finds and injects the
                        required dependency (a bean) into that location.
                    </li>
                    <li>
                        <strong>@Bean:</strong> A method-level annotation used within a <b>@Configuration</b> class to
                        declare a Spring-managed bean. The method's return value will be registered as a bean in the
                        Spring application context.
                    </li>
                </ul>
                <p>These annotations, among many others, are central to the Spring Boot developer experience, enabling
                    rapid development and a highly maintainable codebase.</p>

                <pre><code>
@SpringBootApplication
public class MyApp {
    public static void main(String[] args) {
        SpringApplication.run(MyApp.class, args);
    }
}

@RestController
class HelloController {
    @GetMapping("/hello")
    public String hello() {
        return "Hello, Spring Boot!";
    }
}
    </code></pre>

                <div class="highlight">
                    <p><strong>Spring vs. Spring Boot: A Quick Glance: </strong><br><br>While often used
                        interchangeably,
                        <b>Spring Framework</b> is the extensive, foundational platform for Java application
                        development, providing core features like <b>Dependency Injection</b>.<br><br> <b>Spring
                            Boot</b>, on
                        the other hand, is an opinionated extension that builds on Spring to enable <b>rapid application
                            development</b> by minimizing configuration, offering auto-configuration, and embedding
                        servers for standalone execution.<br><br> Think of Spring as the engine, and Spring Boot as the
                        ready-to-drive car built with that engine.
                    </p>
                </div>
            </section>

            <section class="main-section" id="module7_aop">
                <header>
                    <h2>Module VII: AOP</h2>
                </header>

                <h3>1. Aspect-Oriented Programming (AOP)</h3>
                <p>Aspect-Oriented Programming (AOP) is a programming paradigm that aims to <strong>modularize
                        cross-cutting concerns</strong>. It helps separate concerns like logging, security, transaction
                    management, caching, and performance monitoring from the core business logic of an application. By
                    doing so, AOP promotes greater modularity, reusability, and maintainability of code.</p>

                <h4>Understanding Cross-Cutting Concerns</h4>
                <p>In traditional object-oriented programming (OOP), certain functionalities tend to spread across
                    multiple modules and layers of an application. These are called <strong>cross-cutting
                        concerns</strong>. For example:</p>
                <ul>
                    <li><strong>Logging:</strong> Almost every method might need logging before or after execution to
                        track flow or debug.</li>
                    <li><strong>Security:</strong> Authentication and authorization checks might be required before
                        accessing various resources or methods.</li>
                    <li><strong>Transaction Management:</strong> Ensuring data consistency often involves starting,
                        committing, or rolling back transactions across multiple database operations.</li>
                    <li><strong>Caching:</strong> Implementing caching logic to improve performance often involves
                        adding checks around method calls.</li>
                </ul>
                <p>Without AOP, developers would have to sprinkle the code for these concerns throughout the
                    application, leading to:</p>
                <ul>
                    <li><strong>Code Tangling:</strong> Business logic gets "tangled" with infrastructure concerns,
                        making it harder to understand and modify.</li>
                    <li><strong>Code Scattering:</strong> The same cross-cutting concern logic is "scattered" across
                        many different places, leading to duplication and making changes difficult (e.g., if logging
                        requirements change).</li>
                </ul>

                <h4>How AOP Solves These Problems</h4>
                <p>AOP introduces new constructs to encapsulate these cross-cutting concerns into reusable modules
                    called <strong>aspects</strong>. It then defines mechanisms to <b>"weave"</b> these aspects into the
                    application's core logic at specific points, known as <strong>join points</strong>, without
                    modifying the original code. This process is called <strong>weaving</strong>.</p>

                <h4>Key Concepts in AOP</h4>
                <ul>
                    <li>
                        <strong>Aspect:</strong> A module that encapsulates a cross-cutting concern. It contains advice
                        (what to do) and pointcuts (where to do it). For instance, a logging aspect might contain all
                        the logging logic.
                    </li>
                    <li>
                        <strong>Join Point:</strong> A specific point during the execution of a program, such as a
                        method call, method execution, field access, or exception handling. In Spring AOP, a join point
                        is always a method execution.
                    </li>
                    <li>
                        <strong>Advice:</strong> The actual code that implements the cross-cutting concern. It defines
                        <strong>what</strong> action an aspect will take and <strong>when</strong> it will take it
                        relative to a join point. Common types of advice include:
                        <ul>
                            <li><strong>@Before:</strong> Advice executed before a join point.</li>
                            <li><strong>@After:</strong> Advice executed after a join point, regardless of its outcome
                                (success or exception).</li>
                            <li><strong>@AfterReturning:</strong> Advice executed after a join point completes
                                successfully (i.e., returns without throwing an exception).</li>
                            <li><strong>@AfterThrowing:</strong> Advice executed after a join point throws an exception.
                            </li>
                            <li><strong>@Around:</strong> Advice that surrounds a join point, allowing you to perform
                                actions both before and after the join point, and even to prevent the join point from
                                executing or to return a different value. This is the most powerful type of advice.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Pointcut:</strong> A predicate that matches join points. It defines
                        <strong>where</strong> the advice should be applied. A pointcut expression specifies a set of
                        join points (e.g., "all method executions in the 'service' package").
                    </li>
                    <li>
                        <strong>Target Object:</strong> The object being advised by one or more aspects. This is the
                        object containing the business logic.
                    </li>
                    <li>
                        <strong>Proxy:</strong> An object created by the AOP framework to implement the aspects for the
                        target object. When a method on the target object is called, the call is intercepted by the
                        proxy, which then applies the relevant advice.
                    </li>
                    <li>
                        <strong>Weaving:</strong> The process of applying aspects to target objects to create advised
                        objects (proxies). Weaving can occur at different stages:
                        <ul>
                            <li><strong>Compile-time weaving:</strong> Aspects are woven when the source code is
                                compiled.</li>
                            <li><strong>Load-time weaving (LTW):</strong> Aspects are woven when the class files are
                                loaded into the JVM.</li>
                            <li><strong>Runtime weaving:</strong> Aspects are woven at runtime, typically by generating
                                proxy objects. Spring AOP primarily uses runtime weaving.</li>
                        </ul>
                    </li>
                </ul>

                <h3>2. AOP in Spring Framework</h3>
                <p>Spring AOP is implemented using <strong>dynamic proxies</strong>. When an advised method is called,
                    the Spring AOP container creates a proxy object that intercepts the method call. The proxy then
                    delegates the call to the actual target object after applying the necessary advice. Spring AOP is
                    primarily used to provide enterprise services like transaction management, security, and caching
                    declarative, rather than requiring you to implement them manually in your business logic. It allows
                    developers to define these cross-cutting concerns in a centralized manner, leading to cleaner, more
                    maintainable, and highly modular applications.</p>

                <pre><code>
@Aspect
@Component
public class LoggingAspect {
    @Before("execution(* com.example.service.*.*(..))")
    public void logBefore(JoinPoint joinPoint) {
        System.out.println("Executing: " + joinPoint.getSignature().getName());
    }
}
    </code></pre>
            </section>

            <section class="main-section" id="module8_thymeleaf">
                <header>
                    <h2>Module VIII: Thymeleaf</h2>
                </header>

                <h3>Thymeleaf Basics: An HTML-friendly Template Engine</h3>
                <p>Thymeleaf is a modern server-side Java template engine designed for web and standalone environments.
                    It's often used with Spring Framework for building dynamic web applications. What sets Thymeleaf
                    apart is its philosophy of being <b><q>natural templating</q></b>, meaning your template files can
                    be opened
                    directly in a browser and still display correctly, even before being processed by the server. This
                    makes design and development much more intuitive, as designers and front-end developers can work on
                    the HTML templates without needing a running application server.</p>

                <p>Unlike some other template engines that introduce their own syntax that breaks standard HTML,
                    Thymeleaf uses special attributes <strong>(<cite>e.g.,</cite> <i>th:text</i>, <cite>th:if</cite>,
                        <cite>th:each</cite>)</strong> that are embedded directly into standard HTML tags. These
                    attributes are
                    ignored by browsers, allowing the HTML to render as static content. When the Thymeleaf engine
                    processes the template on the server, it replaces or modifies the content based on these attributes,
                    inserting dynamic data from your Java backend.</p>

                <p>This approach allows for:</p>
                <ul>
                    <li><strong>Natural Prototypes:</strong> HTML templates can be viewed as static prototypes in any
                        browser without a server. Designers can work on the layout and styling, and then developers can
                        easily integrate dynamic content.</li>
                    <li><strong>Clean HTML:</strong> The templates remain valid HTML, making them easier to read,
                        maintain, and integrate with standard web development tools.</li>
                    <li><strong>Server-Side Processing:</strong> All the dynamic content generation happens on the
                        server before the page is sent to the client's browser. This means the client receives a fully
                        rendered HTML page, improving initial load times and simplifying client-side logic.</li>
                    <li><strong>Integration with Spring:</strong> Thymeleaf offers excellent integration with the Spring
                        Framework, providing seamless handling of forms, validation messages, internationalization, and
                        Spring Expression Language (SpEL) support.</li>
                </ul>


                <pre><code>
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Hello</title>
</head>
<body>
    <h1 th:text="'Welcome ' + ${name}">Hello!</h1>
</body>
</html>
    </code></pre>
            </section>

            <section class="main-section" id="module9_postman">
                <header>
                    <h2>Module IX: Postman</h2>
                </header>

                <h3>1. API Testing with Postman</h3>
                <p>Postman is a popular and powerful <strong>API (Application Programming Interface) development
                        environment (ADE)</strong> that simplifies various stages of the API lifecycle, with a strong
                    focus on <strong>testing REST APIs</strong>. It supports all standard HTTP methods and provides
                    robust features to help developers and testers in validating responses, managing API requests, and
                    automating tests.</p>

                <h4>Why Use Postman for API Testing?</h4>
                <p>In modern software development, applications often communicate through APIs. Testing these APIs
                    directly, without relying on a complete UI, is crucial for ensuring their correctness, performance,
                    and reliability. Postman addresses this need by offering a user-friendly interface and extensive
                    capabilities:</p>
                <ul>
                    <li><strong>Ease of Use:</strong> Its intuitive graphical user interface (GUI) makes it easy to
                        construct complex HTTP requests, set headers, manage parameters, and view responses without
                        writing extensive code.</li>
                    <li><strong>Comprehensive HTTP Method Support:</strong> Postman supports all standard HTTP methods
                        including <strong>GET, POST, PUT, DELETE, PATCH, OPTIONS, HEAD</strong>, allowing for full CRUD
                        (Create, Read, Update, Delete) operation testing.</li>
                    <li><strong>Request Customization:</strong> Users can easily customize requests by adding headers,
                        body data (JSON, XML, form-data), query parameters, and authorization details (Basic Auth,
                        Bearer Token, OAuth 2.0).</li>
                    <li><strong>Response Validation:</strong> It provides a clear view of API responses, including
                        status codes, headers, and body content. Testers can inspect the raw response or view it in
                        formatted JSON/XML.</li>
                    <li><strong>Test Automation:</strong> Postman allows writing JavaScript snippets in the "Tests" tab
                        to automate assertions against the response data, status codes, and headers. This enables
                        automated API testing.</li>
                    <li><strong>Collections:</strong> Requests can be organized into collections, making it easy to
                        group related API calls, share them with teams, and run them sequentially.</li>
                    <li><strong>Environment Variables:</strong> It supports environment variables, allowing users to
                        switch between different environments (e.g., development, staging, production) without modifying
                        requests, by simply updating variable values.</li>
                    <li><strong>Mock Servers:</strong> Postman can simulate API endpoints, allowing frontend and backend
                        development teams to work in parallel even if the actual API is not yet fully implemented.</li>
                    <li><strong>Collaboration:</strong> Teams can share collections, environments, and API
                        documentation, fostering better collaboration in API development and testing workflows.</li>
                </ul>

                <p>You can use Postman to test <strong>GET, POST, PUT, DELETE</strong> requests to Spring Boot endpoints
                    (or any other REST API). For instance:</p>
                <ul>
                    <li>A <strong>GET</strong> request to retrieve data from a `/users` endpoint.</li>
                    <li>A <strong>POST</strong> request to create a new user by sending JSON data to a `/users`
                        endpoint.</li>
                    <li>A <strong>PUT</strong> request to update an existing user's details at `/users/{id}`.</li>
                    <li>A <strong>DELETE</strong> request to remove a user from `/users/{id}`.</li>
                </ul>

                <h3>2. Basic Workflow for Testing an API with Postman:</h3>
                <ol>
                    <li><strong>Create a New Request:</strong> Click the '+' tab or 'New' button to create a new HTTP
                        request.</li>
                    <li><strong>Select HTTP Method:</strong> Choose the appropriate method (GET, POST, PUT, DELETE,
                        etc.) from the dropdown.</li>
                    <li><strong>Enter Request URL:</strong> Input the endpoint URL (e.g.,
                        `http://localhost:8080/api/users`).</li>
                    <li><strong>Configure Headers/Body (if applicable):</strong> Add necessary headers (e.g.,
                        `Content-Type: application/json`, `Authorization`) and/or request body data for POST/PUT/PATCH
                        requests.</li>
                    <li><strong>Send Request:</strong> Click the 'Send' button.</li>
                    <li><strong>Inspect Response:</strong> Review the response in the lower panel, checking the status
                        code (e.g., 200 OK, 201 Created, 404 Not Found), response headers, and the response body
                        content.</li>
                    <li><strong>Write Tests (Optional but Recommended):</strong> Use the 'Tests' tab to add JavaScript
                        assertions to automatically validate parts of the response.</li>
                </ol>
            </section>

            <section class="main-section" id="module10_crud">
                <header>
                    <h2>Module X: CRUD Operations</h2>
                </header>

                <h3>1. CRUD in Spring Boot with Spring Data JPA</h3>
                <p>CRUD stands for <strong>Create, Read, Update, and Delete</strong> – the four fundamental operations
                    performed on persistent data in any application. In Spring Boot, these operations are significantly
                    simplified and streamlined through the use of <strong>Spring Data JPA (Java Persistence
                        API)</strong>.</p>

                <h4>Understanding Spring Data JPA for CRUD</h4>
                <p>Spring Data JPA is a sub-project of Spring Data that provides an abstraction layer on top of JPA
                    providers (like <strong>Hibernate</strong>). Its primary goal is to drastically <strong>reduce the
                        amount of boilerplate code</strong> required to implement data access layers (DAOs). Instead of
                    writing concrete implementations for common CRUD methods, you simply declare interfaces, and Spring
                    Data JPA generates the implementations at runtime.</p>

                <h4>Key Components Involved:</h4>
                <ul>
                    <li>
                        <strong>Entity (Model) Class:</strong> This is a plain Java class annotated with
                        <strong>@Entity</strong> (from `jakarta.persistence` package) that maps to a database table.
                        Each instance of this class represents a row in the table, and its properties map to columns. It
                        typically includes annotations like <strong>@Id</strong> for the primary key and
                        <strong>@GeneratedValue</strong> for auto-incrementing IDs.
                    </li>
                    <li>
                        <strong>Repository Interface:</strong> This is a key component where Spring Data JPA truly
                        shines. You define an interface (e.g., `UserRepository`) that extends one of Spring Data JPA's
                        base interfaces, most commonly <strong>JpaRepository</strong> (or
                        <strong>CrudRepository</strong> for basic CRUD).
                        <ul>
                            <li><strong>JpaRepository:</strong> Extends <strong>PagingAndSortingRepository</strong>,
                                which in turn extends <strong>CrudRepository</strong>. It provides methods for basic
                                CRUD operations, as well as pagination and sorting. By simply extending this interface,
                                you automatically get methods like <mark>save()</mark>, <mark>findById()</mark>,
                                <mark>findAll()</mark>, <mark>deleteById()</mark>, etc., without writing any
                                implementation code.
                            </li>
                            <li><strong>CrudRepository:</strong> A more basic interface providing generic CRUD
                                operations like <mark>save()</mark>, <mark>findById()</mark>, <mark>findAll()</mark>,
                                <mark>delete()</mark>, <mark>count()</mark>. <strong>JpaRepository</strong> is generally
                                preferred as it includes more features.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Service Layer (Optional but Recommended):</strong> This layer sits between the
                        controller and the repository. It encapsulates business logic, performs data validation, and can
                        coordinate multiple repository calls within a single transaction. This promotes
                        <strong>separation of concerns</strong> and improves testability.
                    </li>
                    <li>
                        <strong>Controller (REST Controller):</strong> This layer exposes the CRUD functionalities as
                        <strong>RESTful API endpoints</strong>. It receives HTTP requests (GET, POST, PUT, DELETE),
                        interacts with the service layer (which in turn uses the repository), and sends back appropriate
                        HTTP responses (e.g., JSON). Annotations like <strong>@RestController</strong>,
                        <strong>@RequestMapping</strong>, <strong>@GetMapping</strong>, <strong>@PostMapping</strong>,
                        <strong>@PutMapping</strong>, <strong>@DeleteMapping</strong>, <strong>@RequestBody</strong>,
                        and <strong>@PathVariable</strong> are commonly used here.
                    </li>
                </ul>

                <h3>2. Implementing CRUD Operations Step-by-Step (Conceptual):</h3>
                <ol>
                    <li><strong>Create (C):</strong>
                        <ul>
                            <li><strong>Endpoint:</strong> Typically a <strong>POST</strong> request to
                                `/api/resources`.</li>
                            <li><strong>Process:</strong> The client sends an object (e.g., JSON) in the request body.
                                The controller receives this, passes it to the service (optional), which then calls
                                <mark>repository.save(entityObject)</mark>. Spring Data JPA inserts the object into the
                                database.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Read (R):</strong>
                        <ul>
                            <li><strong>All Resources:</strong> Typically a <strong>GET</strong> request to
                                `/api/resources`. The controller calls <mark>repository.findAll()</mark>, which returns
                                all entities.</li>
                            <li><strong>Single Resource by ID:</strong> Typically a <strong>GET</strong> request to
                                `/api/resources/{id}`. The controller extracts the `id` from the path variable and calls
                                <mark>repository.findById(id)</mark>. This method returns an <strong>Optional</strong>,
                                which needs to be handled to check if the entity exists.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Update (U):</strong>
                        <ul>
                            <li><strong>Endpoint:</strong> Typically a <strong>PUT</strong> request to
                                `/api/resources/{id}`.</li>
                            <li><strong>Process:</strong> The client sends the updated object and the ID. The controller
                                first retrieves the existing entity using <mark>findById()</mark>, updates its
                                properties with the new data, and then calls
                                <mark>repository.save(updatedEntityObject)</mark>. If the ID exists, Spring Data JPA
                                performs an update; otherwise, it might perform an insert depending on configuration.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Delete (D):</strong>
                        <ul>
                            <li><strong>Endpoint:</strong> Typically a <strong>DELETE</strong> request to
                                `/api/resources/{id}`.</li>
                            <li><strong>Process:</strong> The controller extracts the `id` from the path variable and
                                calls <mark>repository.deleteById(id)</mark>. Spring Data JPA removes the corresponding
                                record from the database.</li>
                        </ul>
                    </li>
                </ol>

                <div class="highlight">
                    <p><strong>Note: </strong>By leveraging Spring Data JPA, developers can quickly set up robust data
                        access layers for their Spring Boot applications, allowing them to focus more on the business
                        logic rather than tedious database interaction code.</p>
                </div>

                <pre><code>
@Entity
class Product {
    @Id
    @GeneratedValue
    private Long id;
    private String name;
}

@Repository
interface ProductRepository extends JpaRepository<Product, Long> {}

@RestController
class ProductController {
    @Autowired
    private ProductRepository repo;

    @PostMapping("/products")
    public Product add(@RequestBody Product p) {
        return repo.save(p);
    }
}
    </code></pre>
            </section>

            <section class="main-section" id="naming_conventions">
                <header>
                    <h2>Java Naming Conventions</h2>
                </header>

                <p>Java Naming Conventions are a set of widely accepted rules for naming identifiers (like classes,
                    methods, variables, etc.) in Java code. Adhering to these conventions significantly improves code
                    readability, maintainability, and collaboration among developers.</p>

                <p>Here's a breakdown of the standard Java naming conventions:</p>

                <h3>Packages</h3>
                <ul>
                    <li><strong>Rule:</strong> All <b>lowercase</b> letters. If multiple words are used, they are
                        separated by
                        <b>dots</b>. It's common practice to use <b>reverse</b> domain name notation to ensure
                        uniqueness.
                    </li>
                    <li><strong>Examples:</strong></li>
                    <div>
                        <code>java.lang</code>
                        <code>com.example.myproject.utilities</code>
                        <code>org.apache.commons.io</code>
                    </div>
                </ul>

                <h3>Classes</h3>
                <ul>
                    <li><strong>Rule:</strong> Nouns, in <b><q>Upper Camel Case</q></b> (also known as
                        <b>PascalCase</b>). The <b>first letter</b>
                        of each word is <b>capitalized</b>. Should be descriptive.
                    </li>
                    <li><strong>Examples:</strong></li>
                    <div>
                        <code>String</code>
                        <code>ArrayList</code>
                        <code>CustomerAccount</code>
                        <code>ImageProcessor</code>
                    </div>
                </ul>

                <h3>Interfaces</h3>
                <ul>
                    <li><strong>Rule:</strong> Capitalized <b>like class names</b> <b>(Upper Camel Case)</b>. Often
                        describe a
                        capability or a contract.</li>
                    <li><strong>Examples:</strong></li>
                    <div>
                        <code>Runnable</code>
                        <code>Comparable</code>
                        <code>Serializable</code>
                        <code>Printable</code>
                    </div>
                </ul>

                <h3>Methods</h3>
                <ul>
                    <li><strong>Rule:</strong> Verbs, in <b>"lower Camel Case"</b> (also known as <b>mixed case</b>).
                        The <b>first letter
                            is lowercase</b>, and the first letter of <b>subsequent words is capitalized</b>.</li>
                    <li><strong>Examples:</strong></li>
                    <div class="example">
                        <code>main()</code>
                        <code>calculateSum()</code>
                        <code>getFirstName()</code>
                        <code>runFast()</code>
                    </div>
                </ul>

                <h3>Variables</h3>
                <ul>
                    <li><strong>Rule:</strong> In <b>lower Camel Case</b>. Should be short yet meaningful, reflecting
                        their
                        purpose. <b>Avoid</b> starting with <mark>_</mark> or <mark>$</mark> (<b>though allowed</b>,
                        it's not standard
                        practice).</li>
                    <li><strong>Examples:</strong></li>
                    <div>
                        <code>firstName</code>
                        <code>orderNumber</code>
                        <code>myWidth</code>
                        <code>balance</code>
                    </div>
                    <li><strong>Temporary variables:</strong> For short-lived, temporary variables (e.g., loop
                        counters), single-character names are sometimes acceptable (e.g., <mark>i</mark> ,
                        <mark>j</mark> , <mark>k</mark> for <b>integers</b>; <mark>c</mark> , <mark>d</mark> ,
                        <mark>e</mark> for
                        <b>characters</b>).
                    </li>
                </ul>

                <h3>Constants (static final fields)</h3>
                <ul>
                    <li><strong>Rule:</strong> All <b>uppercase</b> letters, with words <b>separated by underscores</b>
                        (<mark>_</mark>).</li>
                    <li><strong>Examples:</strong></li>
                    <div>
                        <code>MAX_VALUE</code>
                        <code>PI</code>
                        <code>DEFAULT_WIDTH</code>
                        <code>MIN_HEIGHT</code>
                    </div>
                </ul>

                <h3>Enums</h3>
                <ul>
                    <li><strong>Enum Type:</strong> <b>Upper Camel Case (like classes)</b>.</li>
                    <li><strong>Enum Constants:</strong> All uppercase with words separated by underscores <b>(like
                            constants)</b>.</li>
                    <li><strong>Example:</strong></li>
                    <div>
                        <pre><code>enum DayOfWeek {
    SUNDAY,
    MONDAY,
    TUESDAY,
    // ...
}</code></pre>
                    </div>
                </ul>

                <h3>General Principles</h3>
                <ul>
                    <li><strong>Descriptive Names:</strong> Choose names that clearly indicate the identifier's purpose,
                        even if they are longer. Avoid vague or overly abbreviated names.</li>
                    <li><strong>Readability:</strong> The primary goal of naming conventions is to make code easy to
                        read and understand for anyone working on it.</li>
                    <li><strong>Consistency:</strong> Stick to the conventions consistently throughout your codebase.
                    </li>
                    <li><strong>Avoid Acronyms/Abbreviations:</strong> Unless an abbreviation is much more widely known
                        than its long form (e.g., URL, HTML), use whole words.</li>
                    <li><strong>Case Sensitivity:</strong> Remember that Java is case-sensitive (<mark>myVariable</mark>
                        is different from <mark>MyVariable</mark>).</li>
                </ul>

                <p>By following these conventions, Java developers contribute to creating clean, professional, and
                    easily maintainable codebases.</p>

            </section>

            <section class="main-section" id="java8_features">
                <header>
                    <h2>Java 8 Features</h2>
                </header>
                <p>Java 8 was a major release that introduced several revolutionary features that transformed Java
                    programming. Released in March 2014, it brought functional programming concepts to Java.</p>

                <div class="module-grid">
                    <div class="module-card">
                        <h3>Lambda Expressions</h3>
                        <p>Enable functional programming in Java with concise syntax for anonymous functions.</p>
                        <pre><code>
// Traditional approach
Runnable r1 = new Runnable() {
    public void run() {
        System.out.println("Hello World");
    }
};

// Lambda expression
Runnable r2 = () -> System.out.println("Hello World");
                        </code></pre>
                    </div>

                    <div class="module-card">
                        <h3>Stream API</h3>
                        <p>Process collections in a functional style with filter, map, reduce operations.</p>
                        <pre><code>
List&lt;String&gt; names = Arrays.asList("John", "Jane", "Jack");
names.stream()
     .filter(name -> name.startsWith("J"))
     .map(String::toUpperCase)
     .forEach(System.out::println);
                        </code></pre>
                    </div>

                    <div class="module-card">
                        <h3>Method References</h3>
                        <p>Shorthand for lambda expressions when calling existing methods.</p>
                        <pre><code>
// Lambda expression
list.forEach(x -> System.out.println(x));

// Method reference
list.forEach(System.out::println);
                        </code></pre>
                    </div>

                    <div class="module-card">
                        <h3>Optional Class</h3>
                        <p>Handle null values more elegantly and avoid NullPointerException.</p>
                        <pre><code>
Optional&lt;String&gt; optional = Optional.ofNullable(getString());
optional.ifPresent(System.out::println);
String value = optional.orElse("Default Value");
                        </code></pre>
                    </div>

                    <div class="module-card">
                        <h3>Default Methods</h3>
                        <p>Add new methods to interfaces without breaking existing implementations.</p>
                        <pre><code>
interface Vehicle {
    void start();
    
    default void horn() {
        System.out.println("Beep beep!");
    }
}
                        </code></pre>
                    </div>

                    <div class="module-card">
                        <h3>Date and Time API</h3>
                        <p>New comprehensive date and time API (java.time package).</p>
                        <pre><code>
LocalDateTime now = LocalDateTime.now();
LocalDate date = LocalDate.of(2024, Month.JANUARY, 1);
Duration duration = Duration.between(start, end);
                        </code></pre>
                    </div>
                </div>
            </section>

            <!-- Java 17 Features Section -->
            <section class="main-section" id="java17_features">
                <header>
                    <h2>Java 17 Features</h2>
                </header>
                <p>Java 17 is a Long Term Support (LTS) release that introduced significant enhancements and new
                    features. Released in September 2021, it focuses on performance improvements, security enhancements,
                    and developer productivity.</p>

                <div class="module-grid">
                    <div class="module-card">
                        <h3>Sealed Classes</h3>
                        <p>Control which classes can extend or implement your classes and interfaces.</p>
                        <pre><code>
public sealed class Shape
    permits Circle, Rectangle, Triangle {
}

public final class Circle extends Shape {
    private final double radius;
}

public final class Rectangle extends Shape {
    private final double width, height;
}
            </code></pre>
                    </div>

                    <div class="module-card">
                        <h3>Pattern Matching for instanceof</h3>
                        <p>Eliminate the need for explicit casting after instanceof checks.</p>
                        <pre><code>
// Traditional approach
if (obj instanceof String) {
    String s = (String) obj;
    System.out.println(s.toUpperCase());
}

// Pattern matching
if (obj instanceof String s) {
    System.out.println(s.toUpperCase());
}
            </code></pre>
                    </div>

                    <div class="module-card">
                        <h3>Context-Specific Deserialization Filters</h3>
                        <p>Enhanced security with context-specific deserialization filters to prevent security
                            vulnerabilities.</p>
                        <pre><code>
// Configure deserialization filter
ObjectInputStream.setObjectInputFilter(
    ObjectInputFilter.Config.createFilter(
        "java.base/*;!*"  // Allow java.base, deny others
    )
);

// Per-stream filter
ObjectInputStream ois = new ObjectInputStream(inputStream);
ois.setObjectInputFilter(info -> {
    if (info.serialClass() == MyClass.class) {
        return ObjectInputFilter.Status.ALLOWED;
    }
    return ObjectInputFilter.Status.REJECTED;
});
            </code></pre>
                    </div>

                    <div class="module-card">
                        <h3>Records</h3>
                        <p>Create immutable data classes with minimal boilerplate code.</p>
                        <pre><code>
public record Person(String name, int age) {}

// Usage
Person person = new Person("John", 25);
System.out.println(person.name()); // John
System.out.println(person.age());  // 25
            </code></pre>
                    </div>

                    <div class="module-card">
                        <h3>Text Blocks</h3>
                        <p>Multi-line string literals that preserve formatting and improve readability.</p>
                        <pre><code>
String json = """
    {
        "name": "John Doe",
        "age": 30,
        "city": "New York"
    }
    """;
            </code></pre>
                    </div>

                    <div class="module-card">
                        <h3>Switch Expressions</h3>
                        <p>Enhanced switch statements with expression syntax and yield keyword.</p>
                        <pre><code>
String result = switch (day) {
    case MONDAY, FRIDAY, SUNDAY -> "6";
    case TUESDAY -> "7";
    case THURSDAY, SATURDAY -> "8";
    case WEDNESDAY -> "9";
    default -> throw new IllegalStateException();
};
            </code></pre>
                    </div>
                </div>
            </section>

            <!-- Java 21 Features Section -->
            <section class="main-section" id="java21_features">
                <header>
                    <h2>Java 21 Features</h2>
                </header>
                <p>Java 21 is the latest Long Term Support (LTS) release that brings cutting-edge features and
                    performance improvements. Released in September 2023, it introduces virtual threads, pattern
                    matching enhancements, sequenced collections, and many other developer-friendly features.</p>

                <div class="module-grid">

                    <div class="module-card">
                        <h3>Pattern Matching for Switch</h3>
                        <p>Enhanced switch expressions with pattern matching capabilities.</p>
                        <pre><code>
String result = switch (obj) {
    case Integer i -> "Integer: " + i;
    case String s when s.length() > 5 -> "Long string: " + s;
    case String s -> "Short string: " + s;
    case null -> "null value";
    default -> "Unknown type";
};
            </code></pre>
                    </div>

                    <div class="module-card">
                        <h3>Record Patterns</h3>
                        <p>Destructure record values in pattern matching contexts.</p>
                        <pre><code>
record Point(int x, int y) {}

// Pattern matching with records
static String describe(Object obj) {
    return switch (obj) {
        case Point(var x, var y) -> "Point[" + x + ", " + y + "]";
        case null -> "null";
        default -> "Unknown";
    };
}
            </code></pre>
                    </div>

                    <div class="module-card">
                        <h3>Sequenced Collections</h3>
                        <p>New interfaces for collections with defined encounter order.</p>
                        <pre><code>
List&lt;String&gt; list = new ArrayList&lt;&gt;();
list.addFirst("first");
list.addLast("last");

String first = list.getFirst();
String last = list.getLast();

list.reversed().forEach(System.out::println);
            </code></pre>
                    </div>

                    <div class="module-card">
                        <h3>Virtual Threads</h3>
                        <p>Lightweight threads that dramatically improve concurrent programming scalability.</p>
                        <pre><code>
// Creating virtual threads
try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
    IntStream.range(0, 10_000).forEach(i -> {
        executor.submit(() -> {
            try {
                Thread.sleep(Duration.ofSeconds(1));
                return i;
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                return -1;
            }
        });
    });
}

// Alternative way to create virtual threads
Thread vThread = Thread.ofVirtual().start(() -> {
    System.out.println("Running in virtual thread");
});
            </code></pre>
                    </div>


                    <div class="module-card">
                        <h3>Sealed Classes Enhancement</h3>
                        <p>Java 21 sealed classes will change your domain modeling. Game-changing integration with
                            pattern matching that revolutionizes how you model business domains. While Java 17
                            introduced sealed classes, Java 21 makes them truly powerful with exhaustive pattern
                            matching and record destructuring.</p>
                        <pre><code>
public sealed interface Result&lt;T&gt;
    permits Success, Error {
}

public record Success&lt;T&gt;(T value) implements Result&lt;T&gt; {}
public record Error&lt;T&gt;(String message) implements Result&lt;T&gt; {}

// Exhaustive pattern matching - compiler ensures all cases covered
String process(Result&lt;String&gt; result) {
    return switch (result) {
        case Success&lt;String&gt;(var value) -> "Got: " + value;
        case Error&lt;String&gt;(var msg) -> "Error: " + msg;
        // No default needed - compiler knows all cases handled!
    };
}
            </code></pre>
                    </div>

                    <div class="module-card">
                        <h3>Unnamed Patterns and Variables</h3>
                        <p>Use underscore (_) for unused variables and patterns to improve code readability.</p>
                        <pre><code>
// Unnamed variables in lambda expressions
map.forEach((_, value) -> System.out.println(value));

// Unnamed patterns in switch
switch (shape) {
    case Rectangle(var width, _) -> 
        System.out.println("Width: " + width);
    case Circle(_) -> 
        System.out.println("It's a circle");
}

// Unnamed variables in try-catch
try {
    riskyOperation();
} catch (Exception _) {
    // Don't care about the exception details
    handleError();
}
            </code></pre>
                    </div>
                </div>
            </section>

            <section class="main-section" id="dsa_concepts">
                <header>
                    <h2>DSA Concepts</h2>
                </header>

                <h3>What is Data Structure?</h3>
                <p>A Data Structure is a way of organizing and storing data so that it can be accessed and modified
                    efficiently. Common types include Arrays, Linked Lists, Stacks, Queues, Trees, Graphs, and Hash
                    Tables.</p>

                <h4>Types of Data Structures</h4>
                <ul>
                    <li><strong>Linear Data Structures:</strong> Arrays, Linked Lists, Stacks, Queues</li>
                    <li><strong>Non-linear Data Structures:</strong> Trees (Binary Tree, BST, AVL, etc.), Graphs
                    </li>
                    <li><strong>Hash-based Structures:</strong> Hash Tables, Hash Maps, Hash Sets</li>
                </ul>

                <h3>What is an Algorithm?</h3>
                <p>An Algorithm is a step-by-step procedure or formula for solving a problem. In computer science,
                    it often refers to a set of rules to perform operations on data structures to solve
                    computational problems.</p>

                <h4>Types of Algorithms</h4>
                <ul>
                    <li><strong>Searching Algorithms:</strong> Linear Search, Binary Search</li>
                    <li><strong>Sorting Algorithms:</strong> Bubble Sort, Selection Sort, Insertion Sort, Merge
                        Sort, Quick Sort</li>
                    <li><strong>Recursive Algorithms:</strong> Used in divide and conquer techniques like Merge
                        Sort, Quick Sort</li>
                    <li><strong>Dynamic Programming:</strong> Used for optimization problems (e.g., Fibonacci,
                        Knapsack)</li>
                    <li><strong>Greedy Algorithms:</strong> Used to find optimal solutions (e.g., Kruskal’s and
                        Prim’s Algorithm)</li>
                    <li><strong>Backtracking:</strong> Used in puzzles and games (e.g., N-Queens Problem)</li>
                    <li><strong>Graph Algorithms:</strong> BFS, DFS, Dijkstra’s, Floyd-Warshall</li>
                </ul>

                <h3>Time Complexity</h3>
                <p>Time Complexity is a measure of the amount of time an algorithm takes to complete as a function
                    of the input size. Common notations include:</p>
                <ul>
                    <li><strong>O(1):</strong> Constant time</li>
                    <li><strong>O(log n):</strong> Logarithmic time</li>
                    <li><strong>O(n):</strong> Linear time</li>
                    <li><strong>O(n log n):</strong> Log-linear time</li>
                    <li><strong>O(n²):</strong> Quadratic time</li>
                </ul>

                <h3>Space Complexity</h3>
                <p>Space Complexity refers to the amount of memory space an algorithm uses relative to the input
                    size. It includes the space used by variables, data structures, and function calls.</p>

                <div class="highlight">
                    <p><strong>The Hidden Superpowers of Your Everyday Tech:</strong><br><br>
                        Every time you use Google Maps to find the fastest route, or Netflix to get movie
                        recommendations, or even just search for a friend on social media – you're experiencing the
                        power of Data Structures and Algorithms (DSA) in action!<br><br>
                        DSA helps these apps sort, store, and process massive amounts of information incredibly fast and
                        efficiently, making
                        your digital life smooth and seamless. It's the secret sauce that makes modern technology work!
                    </p>
                </div>

            </section>

            <section class="main-section" id="references">
                <header>
                    <h2>References</h2>
                </header>

                <ul>
                    <li><a href="https://docs.oracle.com/en/java/" target="_blank">Official Java Documentation</a>
                    </li>
                    <li><a href="https://spring.io/projects/spring-boot" target="_blank">Spring Boot Project</a>
                    </li>
                    <li><a href="https://www.w3schools.com/java/" target="_blank">W3Schools Java Tutorial</a></li>
                    <li><a href="https://www.geeksforgeeks.org/java/" target="_blank">GeeksforGeeks Java</a></li>
                    <li><a href="https://www.geeksforgeeks.org/dsa-tutorial-learn-data-structures-and-algorithms/"
                            target="_blank">GeeksforGeeks DSA Tutorial</a></li>
                    <li><a href="https://www.baeldung.com/" target="_blank">Baeldung - Java & Spring</a></li>
                    <li><a href="https://www.programiz.com/java-programming" target="_blank">Programiz Java
                            Tutorial</a></li>
                </ul>
            </section>
        </main>
    </div>

    <footer>
        <p id="copyright">&#169; 2025 | Designed by <a href="https://www.linkedin.com/in/jabayazhini-ag/"
                target="_blank">Jabayazhini_AG</a> | All Rights Reserved</p>
    </footer>

</body>

</html>